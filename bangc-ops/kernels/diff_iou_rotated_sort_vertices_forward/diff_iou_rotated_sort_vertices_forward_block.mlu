/*************************************************************************
 * Copyright (C) [2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subh_iterect to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/
#include "diff_iou_rotated_sort_vertices_forward.h"

#include "kernels/kernel.h"
#include "kernels/debug.h"
#include "kernels/utils/common.h"

__nram__ char nram_buffer[MAX_NRAM_SIZE];

#if __BANG_ARCH__ >= 372
template <typename T>
static __mlu_func__ void load(const T *addr_vertices, const bool *addr_mask,
                              const int *addr_num_valid, char *nram_vertices,
                              char *nram_mask, char *nram_num_valid,
                              const int dim_m, const int deal_num,
                              const int pingpong_offset, const int pi) {
  int offset = (pi % 2) * pingpong_offset;
  T *nram_vertices_p = (T *)(nram_vertices + offset);
  bool *nram_mask_p = (bool *)(nram_mask + offset);
  int *nram_num_valid_p = (int *)(nram_num_valid + offset);

  int deal_mask_num = deal_num * dim_m;
  int deal_vertices_num = deal_num * dim_m * 2;

  __memcpy_async(nram_vertices_p, addr_vertices, deal_vertices_num * sizeof(T),
                 GDRAM2NRAM);
  __memcpy_async(nram_mask_p, addr_mask, deal_mask_num * sizeof(bool),
                 GDRAM2NRAM);
  __memcpy_async(nram_num_valid_p, addr_num_valid, deal_num * sizeof(int),
                 GDRAM2NRAM);
}

template <typename T>
static __mlu_func__ void computeDiv(T *nram_dst, T *nram_src0, T *nram_src1,
                                    int deal_num) {
  if (sizeof(T) == sizeof(float)) {
#if (__BANG_ARCH__ != 372)
    __bang_div((float *)nram_dst, (float *)nram_src0, (float *)nram_src1,
               deal_num);
#else
    __bang_recip((float *)nram_dst, (float *)nram_src1, deal_num);
    __bang_mul((float *)nram_dst, (float *)nram_src0, (float *)nram_dst,
               deal_num);
#endif
  }
}

template <typename T>
static __mlu_func__ void compute_cosine(T *nram_vertices,
                                        const bool *nram_vertices_mask,
                                        T *nram_mask0, T *nram_temp0,
                                        T *nram_temp1, const int point_num) {
  T *nram_vertices_x = nram_vertices;
  T *nram_vertices_y = nram_vertices + point_num;
  __bang_transpose(nram_temp0, nram_vertices, point_num, 2);
  __bang_move(nram_vertices_x, nram_temp0, 2 * point_num * sizeof(T));

  // y < 0
  __bang_lt_scalar(nram_mask0, nram_vertices_y, (T)0.0, point_num);
  // y >= 0
  __bang_not(nram_temp1, nram_mask0, point_num);
  __bang_mul_scalar(nram_mask0, nram_mask0, (T)-1.0, point_num);
  __bang_add(nram_temp1, nram_temp1, nram_mask0, point_num);
  __bang_mul(nram_vertices_x, nram_vertices_x, nram_temp1, point_num);

  // compute x * x + y * y + EPSILON
  __bang_square(nram_temp0, nram_vertices_x, point_num);
  __bang_square(nram_temp1, nram_vertices_y, point_num);
  __bang_add(nram_temp0, nram_temp0, nram_temp1, point_num);
  __bang_add_scalar(nram_temp0, nram_temp0, (T)EPSILON, point_num);
  // fabs(x) * x;
  __bang_abs(nram_temp1, nram_vertices_x, point_num);
  __bang_mul(nram_temp1, nram_temp1, nram_vertices_x, point_num);

  // cosine[point_num] = fabs(x) * x / (x * x + y * y + EPSILON)
  computeDiv(nram_temp0, nram_temp1, nram_temp0, point_num);

  __bang_mul_scalar(nram_mask0, nram_mask0, (T)2.0, point_num);
  __bang_add(nram_temp0, nram_temp0, nram_mask0, point_num);

  // set y=0 and vertices_mask=0 points cos value is -4
  __bang_ne_scalar(nram_mask0, nram_vertices_y, (T)0.0, point_num);
  __bang_int82float(nram_temp1, (int8_t *)(nram_vertices_mask), point_num, 0);
  __bang_and(nram_mask0, nram_mask0, nram_temp1, point_num);
  __bang_mul(nram_temp0, nram_temp0, nram_mask0, point_num);
  __bang_not(nram_mask0, nram_mask0, point_num);
  __bang_mul_scalar(nram_mask0, nram_mask0, (T)UNVALID_VALUE, point_num);
  __bang_add(nram_mask0, nram_temp0, nram_mask0, point_num);
}

template <typename T>
static __mlu_func__ bool duplicate_box_check(T *nram_temp, T *nram_cos,
                                             T *nram_vertices_p, int k,
                                             int dim_m, int deal_num) {
  bool result = true;
  int counter = 4;
  for (int i = 0; i < 4; i++) {
    T x1 = (nram_vertices_p + dim_m * k)[i];
    T y1 = (nram_vertices_p + dim_m * (k + deal_num))[i];
    for (int j = 0; j < 4; j++) {
      T x2 = (nram_vertices_p + dim_m * k + 4)[j];
      T y2 = (nram_vertices_p + dim_m * (k + deal_num) + 4)[j];
      if (fabs(x2 - x1) < EPSILON && fabs(y2 - y1) < EPSILON) counter--;
    }
    if (counter + i + 1 != 4) {
      result = false;
      return result;
    }
  }
  return result;
}

template <typename T>
static __mlu_func__ void compute(char *nram_vertices, char *nram_mask,
                                 char *nram_num_valid, char *nram_idx,
                                 T *nram_pub_space, const int dim_m,
                                 const int deal_num, const int pingpong_offset,
                                 const int pi) {
  int offset = (pi % 2) * pingpong_offset;
  T *nram_vertices_p = (T *)(nram_vertices + offset);
  bool *nram_mask_p = (bool *)(nram_mask + offset);
  int *nram_num_valid_p = (int *)(nram_num_valid + offset);
  int *nram_idx_p = (int *)(nram_idx + offset);

  // nram_pub_space size = 4 * dim_m * deal_num
  T *nram_pad = nram_pub_space;
  T *nram_mask0 = nram_pad + deal_num * dim_m;
  T *nram_temp0 = nram_mask0 + deal_num * dim_m;
  T *nram_temp1 = nram_temp0 + deal_num * dim_m;

  // compute all points cosine value
  compute_cosine(nram_vertices_p, nram_mask_p, nram_mask0, nram_temp0,
                 nram_temp1, deal_num * dim_m);

  // preprocess to get pad index
  __bang_write_zero(nram_temp0, dim_m);
  __bang_write_value(nram_temp0, INTERSECTION_OFFSET, (T)1.0);
  __bang_int82float(nram_pad, (int8_t *)(nram_mask_p), deal_num * dim_m, 0);
  __bang_cycle_maxequal(nram_pad, nram_pad, nram_temp0, deal_num * dim_m,
                        dim_m);
  __bang_not(nram_pad, nram_pad, deal_num * dim_m);

  for (int i = 0; i < deal_num; i++) {
    int num_valid_points = nram_num_valid_p[i];
    int pad = (int)__bang_findfirst1(nram_pad + i * dim_m, dim_m);
    __bang_write_value(nram_idx_p + i * MAX_NUM_VERT_IDX, MAX_NUM_VERT_IDX,
                       pad);

    if (num_valid_points >= 3) {
      int skip_vertices = 0;
      T *nram_cos = nram_mask0 + i * dim_m;
      if (num_valid_points == 8 &&
          duplicate_box_check(nram_temp0, nram_cos, nram_vertices_p, i, dim_m,
                              deal_num)) {
        // for corner case: the two boxes are exactly the same.
        // in this case, idx would have duplicate elements, which makes the
        // shoelace formula broken because of the definition, the duplicate
        // elements only appear in the first 8 positions (they are "corners in
        // box", not "intersection of edges")
        num_valid_points = 4;
        __bang_write_zero(nram_idx_p + i * MAX_NUM_VERT_IDX, num_valid_points);
        for (int j = 0; j < num_valid_points; ++j) {
          __bang_argmax(nram_temp0, nram_cos, 4);
          int i_take = (int)(*(uint32_t *)(nram_temp0 + 1));
          nram_idx_p[i * MAX_NUM_VERT_IDX + j] = i_take;
          nram_cos[i_take] = (T)UNVALID_VALUE;
        }
      } else {
        __bang_write_zero(nram_idx_p + i * MAX_NUM_VERT_IDX, num_valid_points);

        // sort the valid vertices
        // note the number of valid vertices is known
        // note: check that num_valid[i] < MAX_NUM_VERT_IDX
        T pre_cos = (T)UNVALID_VALUE;
        int pre_idx = -1;
        for (int j = 0; j < num_valid_points; ++j) {
          __bang_argmax(nram_temp0, nram_cos, dim_m);
          int i_take = (int)(*(uint32_t *)(nram_temp0 + 1));
          T cos_max = nram_temp0[0];
          nram_idx_p[i * MAX_NUM_VERT_IDX + j] = i_take;
          nram_cos[i_take] = (T)UNVALID_VALUE;
          if (j > 0) {
            if (pre_cos - cos_max < EPSILON) {
              T x2 = (nram_vertices_p + i * dim_m)[i_take];
              T y2 = (nram_vertices_p + (i + deal_num) * dim_m)[i_take];
              T x1 = (nram_vertices_p + i * dim_m)[pre_idx];
              T y1 = (nram_vertices_p + (i + deal_num) * dim_m)[pre_idx];
              if ((fabs(x1 - x2) < EPSILON && fabs(y2 - y1) < EPSILON) ||
                  !(y1 < 0 && y2 < 0) || (y1 > 0 && y2 > 0)) {
                // if duplicated, set unvalid idx
                nram_idx_p[i * MAX_NUM_VERT_IDX + j] = (int)UNVALID_IDX;
                skip_vertices++;
                continue;
              } else {
                nram_idx_p[i * MAX_NUM_VERT_IDX + j - 1] = i_take;
                nram_idx_p[i * MAX_NUM_VERT_IDX + j] = pre_idx;
                cos_max = pre_cos;
                i_take = pre_idx;
              }
            }
          }
          pre_cos = cos_max;
          pre_idx = i_take;
        }
      }
      // duplicate the first idx
      nram_idx_p[i * MAX_NUM_VERT_IDX + num_valid_points] =
          nram_idx_p[i * MAX_NUM_VERT_IDX + 0];

      if (skip_vertices) {  // deal with the unvalid idx
        __bang_int322float((float *)nram_temp0,
                           nram_idx_p + i * MAX_NUM_VERT_IDX, num_valid_points,
                           0);
        __bang_eq_scalar((float *)nram_temp1, (float *)nram_temp0,
                         (float)UNVALID_IDX, num_valid_points);
        __bang_not((float *)nram_temp1, (float *)nram_temp1, num_valid_points);
        __bang_collect((float *)nram_temp0, (float *)nram_temp0,
                       (float *)nram_temp1, num_valid_points);
        __bang_float2int32_tz(nram_idx_p + i * MAX_NUM_VERT_IDX,
                              (float *)nram_temp0,
                              num_valid_points - skip_vertices, 0);
        __bang_write_value(nram_idx_p + i * MAX_NUM_VERT_IDX +
                               num_valid_points - skip_vertices,
                           skip_vertices, 0);
      }
    }
  }
}

static __mlu_func__ void store(int *addr_idx, char *nram_idx,
                               const int deal_idx_num,
                               const int pingpong_offset, const int pi) {
  int offset = (pi % 2) * pingpong_offset;
  int *nram_idx_p = (int *)(nram_idx + offset);
  __memcpy_async(addr_idx, nram_idx_p, deal_idx_num * sizeof(int), NRAM2GDRAM);
}

template <typename T>
static __mlu_func__ void lcs(const T *base_vertices, const bool *base_mask,
                             const int *base_num_valid, int *base_idx,
                             char *nram_vertices, char *nram_mask,
                             char *nram_num_valid, char *nram_idx,
                             T *nram_pub_space, const int deal_num,
                             const int repeat_n, const int rem_num,
                             const int rem_offset, const int dim_m,
                             const int pingpong_offset) {
  const uint32_t deal_num_device = taskDim * deal_num;
  const uint32_t task_data_offset = taskId * deal_num;
  const uint32_t deal_idx_num = deal_num * MAX_NUM_VERT_IDX;

  if (repeat_n > 0) {
    // L
    const T *addr_vertices = base_vertices + task_data_offset * dim_m * 2;
    const bool *addr_mask = base_mask + task_data_offset * dim_m;
    const int *addr_num_valid = base_num_valid + task_data_offset;
    load(addr_vertices, addr_mask, addr_num_valid, nram_vertices, nram_mask,
         nram_num_valid, dim_m, deal_num, pingpong_offset, 0);
    __sync();
  }

  if (repeat_n > 1) {
    // L
    const T *addr_vertices =
        base_vertices + (deal_num_device + task_data_offset) * dim_m * 2;
    const bool *addr_mask =
        base_mask + (deal_num_device + task_data_offset) * dim_m;
    const int *addr_num_valid =
        base_num_valid + deal_num_device + task_data_offset;
    load(addr_vertices, addr_mask, addr_num_valid, nram_vertices, nram_mask,
         nram_num_valid, dim_m, deal_num, pingpong_offset, 1);

    // C
    compute<float>(nram_vertices, nram_mask, nram_num_valid, nram_idx,
                   nram_pub_space, dim_m, deal_num, pingpong_offset, 0);
    __sync();
  }

  for (int n_iter = 0; n_iter < repeat_n - 2; n_iter++) {
    // S
    int *addr_idx = base_idx + (n_iter * deal_num_device + task_data_offset) *
                                   MAX_NUM_VERT_IDX;
    store(addr_idx, nram_idx, deal_idx_num, pingpong_offset, n_iter);

    // L
    const T *addr_vertices =
        base_vertices +
        ((n_iter + 2) * deal_num_device + task_data_offset) * dim_m * 2;
    const bool *addr_mask =
        base_mask + ((n_iter + 2) * deal_num_device + task_data_offset) * dim_m;
    const int *addr_num_valid =
        base_num_valid + (n_iter + 2) * deal_num_device + task_data_offset;
    load(addr_vertices, addr_mask, addr_num_valid, nram_vertices, nram_mask,
         nram_num_valid, dim_m, deal_num, pingpong_offset, n_iter + 2);

    // C
    compute<float>(nram_vertices, nram_mask, nram_num_valid, nram_idx,
                   nram_pub_space, dim_m, deal_num, pingpong_offset,
                   n_iter + 1);
    __sync();
  }

  if (repeat_n >= 2) {
    // S
    int *addr_idx =
        base_idx + ((repeat_n - 2) * deal_num_device + task_data_offset) *
                       MAX_NUM_VERT_IDX;
    store(addr_idx, nram_idx, deal_idx_num, pingpong_offset, (repeat_n - 2));
  }
  if (rem_num > 0) {
    // L
    const T *addr_vertices =
        base_vertices + (repeat_n * deal_num_device + rem_offset) * dim_m * 2;
    const bool *addr_mask =
        base_mask + (repeat_n * deal_num_device + rem_offset) * dim_m;
    const int *addr_num_valid =
        base_num_valid + repeat_n * deal_num_device + rem_offset;
    load(addr_vertices, addr_mask, addr_num_valid, nram_vertices, nram_mask,
         nram_num_valid, dim_m, rem_num, pingpong_offset, repeat_n);
  }
  if (repeat_n > 0) {
    // C
    compute<float>(nram_vertices, nram_mask, nram_num_valid, nram_idx,
                   nram_pub_space, dim_m, deal_num, pingpong_offset,
                   repeat_n - 1);
  }
  __sync();

  if (repeat_n > 0) {
    // S
    int *addr_idx =
        base_idx + ((repeat_n - 1) * deal_num_device + task_data_offset) *
                       MAX_NUM_VERT_IDX;
    store(addr_idx, nram_idx, deal_idx_num, pingpong_offset, (repeat_n - 1));
  }
  if (rem_num > 0) {
    // C
    compute<float>(nram_vertices, nram_mask, nram_num_valid, nram_idx,
                   nram_pub_space, dim_m, rem_num, pingpong_offset, repeat_n);
    __sync();

    // S
    int *addr_idx =
        base_idx + (repeat_n * deal_num_device + rem_offset) * MAX_NUM_VERT_IDX;
    store(addr_idx, nram_idx, rem_num * MAX_NUM_VERT_IDX, pingpong_offset,
          repeat_n);
  }
}
#endif

template <typename T>
__mlu_global__ void MLUKernelDiffIouRotatedSortVerticesForward(
    const T *vertices, const bool *mask, const int *num_valid, int *idx,
    const int dim_b, const int dim_n, const int dim_m) {
#if __BANG_ARCH__ >= 372
  if (__is_mpu()) {
    return;
  }

  int total_bn_num = dim_b * dim_n;

  // nram space
  // nram_pub_space
  // |--------------------------------------|
  // |           nram_pub_space             |
  // |--------------------------------------|
  // |  4 * deal_num * dim_m * sizeof(T)    |
  // |--------------------------------------|
  // pingpong
  // |--------------------------------------|--------------------------------|
  // |           nram_vertices              |            nram_mask           |
  // |--------------------------------------|--------------------------------|
  // | deal_num * dim_m * 2 * sizeof(T)     | deal_num * dim_m * sizeof(bool)|
  // |--------------------------------------|--------------------------------|
  // |           nram_num_valid             |           nram_idx             |
  // |        deal_num * sizeof(int)        |   9 * deal_num * sizeof(int)   |
  // |--------------------------------------|--------------------------------|
  int deal_num = MAX_NRAM_SIZE / 2 /
                 (4 * dim_m * sizeof(T) + dim_m * sizeof(bool) +
                  (1 + MAX_NUM_VERT_IDX) * sizeof(int));
  int deal_vertices_num = deal_num * dim_m * 2;
  int deal_mask_num = deal_num * dim_m;
  int deal_num_valid_num = deal_num;
  int max_nram_size = MAX_NRAM_SIZE - 4 * deal_num * dim_m * sizeof(T);
  int pingpong_offset = max_nram_size / 2;

  T *nram_pub_space = (T *)nram_buffer;

  // ping/pong
  char *nram_vertices = (char *)(nram_pub_space + 4 * deal_num * dim_m);
  char *nram_mask = nram_vertices + deal_vertices_num * sizeof(T);
  char *nram_num_valid = nram_mask + deal_mask_num * sizeof(bool);
  char *nram_idx = nram_num_valid + deal_num_valid_num * sizeof(int);

  int repeat_n = total_bn_num / (deal_num * taskDim);
  int rem_num_device = total_bn_num % (deal_num * taskDim);
  int rem_num_per_task = rem_num_device / taskDim;
  int rem_bn_num = rem_num_device % taskDim;
  int rem_num = rem_num_per_task + (int)((taskId < rem_bn_num));
  int rem_offset =
      taskId * rem_num_per_task + ((taskId < rem_bn_num) ? taskId : rem_bn_num);

  if (repeat_n == 0 && rem_num == 0) {
    return;
  }

  lcs(vertices, mask, num_valid, idx, nram_vertices, nram_mask, nram_num_valid,
      nram_idx, nram_pub_space, deal_num, repeat_n, rem_num, rem_offset, dim_m,
      pingpong_offset);
#endif
}

void MLUOP_WIN_API KernelDiffIouRotatedSortVerticesForward(
    cnrtDim3_t k_dim, cnrtFunctionType_t k_type, cnrtQueue_t queue,
    const void *vertices, const void *mask, const void *num_valid, void *idx,
    const int dim_b, const int dim_n, const int dim_m) {
  MLUKernelDiffIouRotatedSortVerticesForward<<<k_dim, k_type, queue>>>(
      (float *)vertices, (bool *)mask, (int *)num_valid, (int *)idx, dim_b,
      dim_n, dim_m);
}
