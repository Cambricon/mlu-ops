
#include "sgetrf.h"

#include "core/logging.h"
#include "kernels/debug.h"
#include "kernels/kernel.h"


#define NB 4 //same as cnrtFunctionType
#define MAX_NB 32
#define CEILDIV(x, y) ((x + y - 1) / y)
__mlu_shared__ float sA[NB * NB];
__mlu_shared__ float sB[NB * MAX_NB];

__mlu_entry__ void MLUKernelTrsm(
    int m, int n,
    float *dA, int32_t ldda,
    float *dB, int32_t lddb)
{

    const int tx = taskIdX;
    const int ty = taskIdY;

    // 初始化sA和sB
    __sramset(sA, NB * NB, 0);
    __sramset(sB, NB * MAX_NB, 0);

    const int nblocks = CEILDIV(n, NB);
    const int n_ = n - (nblocks - 1) * NB;

    //load A

    if (ty < n && tx < m)
    {

        if (tx - 1 >= 0)
            __memcpy(sA + tx * NB, dA + tx * ldda, (tx) * sizeof(float), LDRAM2SRAM, NB * sizeof(float), ldda * sizeof(float), 0);
    }

    if (ty == tx)
    {
        // ignore diagonal elements
        sA[tx * NB + tx] = 1.0;
        // printf("%.2f \n",sA[tx * NB + tx]);
    }

    __sync_cluster();

    for (int s = 0; s < nblocks - 1; s++)
    {

        // load B
        if (ty < n && tx < m)
        {
            __memcpy(sB + tx * MAX_NB, dB + tx * lddb, (NB) * sizeof(float), LDRAM2SRAM, MAX_NB * sizeof(float), lddb * sizeof(float), 0);
        }
        __sync_cluster();

        //solve B = A^-1 * B

        float sum = sB[ty + tx * MAX_NB];
        float c = 0;
        for (int i = 0; i < NB; i++)
        {
            if (tx > i)
            {
                float y = -sA[i + tx * NB] * sB[ty + i * MAX_NB] - c;
                float t = sum + y;
                c = (t - sum) - y;
                sum = t;
                sB[ty + tx * MAX_NB] = sum;
                // sB[ ty  + tx * MAX_NB ] -= sA[ i  + tx * NB ] * sB[ ty  + i * MAX_NB ];
            }
        }
        // __sync_cluster();

        // write B
        if (tx < m)
        {

            dB[ty + tx * lddb] = sB[ty + tx * MAX_NB];
        }
        dB += NB;
    }

    // last, possible partial, block
    // printf("last, possible partial, block\n");
    // printf("tx ty %d %d loading sB\n",tx,ty);

    if (ty < n_ && tx < m)
    {
        __memcpy(sB + tx * MAX_NB, dB + tx * lddb, (n_) * sizeof(float), LDRAM2SRAM, MAX_NB * sizeof(float), lddb * sizeof(float), 0);
    }
    __sync_cluster();
    float sum = sB[ty + tx * MAX_NB];
    float c = 0;
    for (int i = 0; i < NB; i++)
    {
        if (tx > i)
        {
            float y = -sA[i + tx * NB] * sB[ty + i * MAX_NB] - c;
            float t = sum + y;
            c = (t - sum) - y;
            sum = t;
            sB[ty + tx * MAX_NB] = sum;
            // sB[ ty + tx *  MAX_NB ] -= sA[ i + tx * NB ] * sB[ ty + i * MAX_NB];
        }
    }
    // __sync_cluster();

    if (ty < n_ && tx < m)
    {

        dB[ty + tx * lddb] = sB[ty + tx * MAX_NB];
    }
}

mluOpStatus_t MLUOP_WIN_API KernelTrsm(cnrtDim3_t k_dim, cnrtFunctionType_t k_type,
                                       cnrtQueue_t queue, mluOpDataType_t d_type,
                                       int m, int n,
                                       float *dA, int32_t ldda,
                                       float *dB, int32_t lddb)
{

    KERNEL_CHECK(
        MLUKernelTrsm<<<k_dim, k_type, queue>>>(m, n, dA, ldda, dB, lddb));

    return MLUOP_STATUS_SUCCESS;
}