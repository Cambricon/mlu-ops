/*************************************************************************
 * Copyright (C) [2019-2022] by Cambricon, Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/

#include "mlu.h"
#include "core/mlu_op_core.h"
#include "kernels/poly_nms/pnms.h"
#include "kernels/kernel.h"
#include "pnms_detection.h"

#define NRAM_BUF_SIZE (MAX_NRAM_SIZE)
#define SIZE_SRAM_BUF (NRAM_BUF_SIZE)

__nram__ char nram_buffer[NRAM_BUF_SIZE];
__mlu_shared__ char sram_buffer[SIZE_SRAM_BUF];

__mlu_func__ void boxesTranspose(const void *input_boxes,
                                 const int input_num_boxes,
                                 const int input_stride, void *output,
                                 void *buffer, const int buffer_size,
                                 const mluOpDataType_t data_type_input) {
  if (coreId == 0) {
    // Trans boxes: Nx9 -> 9xN
#if __BANG_ARCH__ >= 300
    float *boxes;
    float *trans_boxes;
    boxes = (float *)buffer;
    trans_boxes = boxes + input_num_boxes * input_stride;
    // Transpose no need to align
    __memcpy((float *)boxes, (float *)input_boxes,
             input_num_boxes * input_stride * 4, GDRAM2NRAM);
    __bang_transpose((float *)trans_boxes, (float *)boxes, input_num_boxes,
                     input_stride);
    __memcpy((float *)output, (float *)trans_boxes,
             input_num_boxes * input_stride * 4, NRAM2GDRAM);
#else
    const int ALIGN_SIZE = 128;
    const int align_num = ALIGN_SIZE / 4;
    // align input_stride->align_stride, align  input_num_boxes->align_box_num
    int align_box_num = CEIL_ALIGN(input_num_boxes, align_num);
    int align_stride = CEIL_ALIGN(input_stride, align_num);
    int transpose_num = align_box_num * align_stride;

    float *boxes;
    float *trans_boxes;
    boxes = (float *)buffer;
    trans_boxes = (float *)boxes + transpose_num;
    __memcpy((float *)boxes, (float *)input_boxes, input_stride * sizeof(float),
             GDRAM2NRAM, align_stride * sizeof(float),
             input_stride * sizeof(float), input_num_boxes);

    __bang_transpose((float *)trans_boxes, (float *)boxes, align_box_num,
                     align_stride);

    __memcpy((float *)output, (float *)trans_boxes,
             input_num_boxes * sizeof(float), NRAM2GDRAM,
             input_num_boxes * sizeof(float), align_box_num * sizeof(float),
             input_stride);
#endif  // BANG_ARCH if
  }
  __sync_cluster();
}

__mlu_global__ void MLUUnion1OrBlockPNMS(const void *input_boxes,
                                         int input_num_boxes, int input_stride,
                                         const float iou_thresh,
                                         void *result_num, void *output,
                                         const mluOpDataType_t data_type_input,
                                         void *workspace) {
  void *trans_boxes = (char *)workspace;
  boxesTranspose(input_boxes, input_num_boxes, input_stride, trans_boxes,
                 nram_buffer, NRAM_BUF_SIZE, data_type_input);

  uint32_t input_data_num = input_stride * input_num_boxes;  // N*P
  input_stride = input_num_boxes;                            // N

  uint32_t *out_data = (uint32_t *)output;
  switch (data_type_input) {
    case MLUOP_DTYPE_FLOAT: {
      pnms_detection<float, uint32_t>(
          (uint32_t *)result_num, out_data, (float *)trans_boxes,
          (float *)nram_buffer, NRAM_BUF_SIZE, (float *)sram_buffer, taskDim,
          input_data_num, input_stride, iou_thresh);
    }; break;
    default: { __bang_printf("Not Implemented.\n"); }
  }
  // PERF_TIME_END();
}
