/*************************************************************************
 * Copyright (C) [2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/
#include "fill.h"

/******************************************************************************
 * Cambricon CNNL Data Type
 ******************************************************************************/
/* Enumeration variables describing the data types in Cambricon CNNL. */
typedef enum {
  CNNL_DTYPE_INVALID = 0, /*!< The data is an invalid data type. */
  CNNL_DTYPE_HALF = 1,    /*!< The data is a 16-bit floating-point data type. */
  CNNL_DTYPE_FLOAT = 2,   /*!< The data is a 32-bit floating-point data type. */
  CNNL_DTYPE_DOUBLE = 14, /*!< The data is a 64-bit floating-point data type. */
  CNNL_DTYPE_INT8 = 3,    /*!< The data is a 8-bit signed integer data type. */
  CNNL_DTYPE_INT16 = 4,   /*!< The data is a 16-bit signed integer data type. */
  CNNL_DTYPE_INT31 = 5,   /*!< The data is a 31-bit signed integer data type. */
  CNNL_DTYPE_INT32 = 6,   /*!< The data is a 32-bit signed integer data type. */
  CNNL_DTYPE_INT64 = 9,   /*!< The data is a 64-bit signed integer data type. */
  CNNL_DTYPE_UINT8 = 7, /*!< The data is a 8-bit unsigned integer data type. */
  CNNL_DTYPE_UINT16 =
      13, /*!< The data is a 16-bit unsigned integer data type. */
  CNNL_DTYPE_UINT32 =
      11, /*!< The data is a 32-bit unsigned integer data type. */
  CNNL_DTYPE_UINT64 =
      12,              /*!< The data is a 64-bit unsigned integer data type. */
  CNNL_DTYPE_BOOL = 8, /*!< The data is a boolean data type. */
  CNNL_DTYPE_COMPLEX_HALF =
      15, /*!< The data is a 32-bit complex number of two fp16. */
  CNNL_DTYPE_COMPLEX_FLOAT =
      16, /*!< The data is a 64-bit complex number of two fp32. */
} cnnlDataType_t;

// convert mluOpDataType_t to cnnlDataType_t
static inline cnnlDataType_t convertDatatype(mluOpDataType_t k_datatype) {
  switch (k_datatype) {
    case MLUOP_DTYPE_INVALID:
      return CNNL_DTYPE_INVALID;
    case MLUOP_DTYPE_HALF:
      return CNNL_DTYPE_HALF;
    case MLUOP_DTYPE_FLOAT:
      return CNNL_DTYPE_FLOAT;
    case MLUOP_DTYPE_DOUBLE:
      return CNNL_DTYPE_DOUBLE;
    case MLUOP_DTYPE_INT8:
      return CNNL_DTYPE_INT8;
    case MLUOP_DTYPE_INT16:
      return CNNL_DTYPE_INT16;
    case MLUOP_DTYPE_INT32:
      return CNNL_DTYPE_INT32;
    case MLUOP_DTYPE_INT64:
      return CNNL_DTYPE_INT64;
    case MLUOP_DTYPE_UINT8:
      return CNNL_DTYPE_UINT8;
    case MLUOP_DTYPE_UINT16:
      return CNNL_DTYPE_UINT16;
    case MLUOP_DTYPE_UINT32:
      return CNNL_DTYPE_UINT32;
    case MLUOP_DTYPE_UINT64:
      return CNNL_DTYPE_UINT64;
    case MLUOP_DTYPE_BOOL:
      return CNNL_DTYPE_BOOL;
    case MLUOP_DTYPE_COMPLEX_HALF:
      return CNNL_DTYPE_COMPLEX_HALF;
    case MLUOP_DTYPE_COMPLEX_FLOAT:
      return CNNL_DTYPE_COMPLEX_FLOAT;
  }
}

// FillDeviceValue
__mlu_global__ void MLUUnion1KernelFillDeviceValue(void *output, size_t size,
                                                   const void *value,
                                                   cnnlDataType_t k_datatype);

void MLUOP_WIN_API KernelFillDeviceValue(
    cnrtDim3_t k_dim, cnrtFunctionType_t k_type, cnrtQueue_t queue,
    mluOpDataType_t k_datatype, void *output, size_t size, const void *value) {
  cnnlDataType_t cnnl_k_datatype = convertDatatype(k_datatype);
  MLUUnion1KernelFillDeviceValue<<<k_dim, k_type, queue>>>(output, size, value,
                                                           cnnl_k_datatype);
}

// FillHostValue
__mlu_global__ void MLUUnion1KernelFillHostValue(void *output, size_t size,
                                                 uint32_t value,
                                                 uint32_t value_high,
                                                 uint32_t value_low,
                                                 cnnlDataType_t k_datatype);

void MLUOP_WIN_API KernelFillHostValue(
    cnrtDim3_t k_dim, cnrtFunctionType_t k_type, cnrtQueue_t queue,
    mluOpDataType_t k_datatype, void *output, size_t size, uint32_t value,
    uint32_t value_high, uint32_t value_low) {
  cnnlDataType_t cnnl_k_datatype = convertDatatype(k_datatype);
  MLUUnion1KernelFillHostValue<<<k_dim, k_type, queue>>>(
      output, size, value, value_high, value_low, cnnl_k_datatype);
}

// FillDeviceValueWithStride
__mlu_global__ void MLUUnion1KernelFillDeviceValueWithStride(
    void *output, TensorShape output_shape, size_t size, const void *value,
    cnnlDataType_t k_datatype);

void MLUOP_WIN_API KernelFillDeviceValueWithStride(
    cnrtDim3_t k_dim, cnrtFunctionType_t k_type, cnrtQueue_t queue,
    mluOpDataType_t k_datatype, void *output, TensorShape output_shape,
    size_t size, const void *value) {
  cnnlDataType_t cnnl_k_datatype = convertDatatype(k_datatype);
  MLUUnion1KernelFillDeviceValueWithStride<<<k_dim, k_type, queue>>>(
      output, output_shape, size, value, cnnl_k_datatype);
}

// FillHostValueWithStride
__mlu_global__ void MLUUnion1KernelFillHostValueWithStride(
    void *output, TensorShape output_shape, size_t size, uint32_t value,
    uint32_t value_high, uint32_t value_low, cnnlDataType_t k_datatype);

void MLUOP_WIN_API KernelFillHostValueWithStride(
    cnrtDim3_t k_dim, cnrtFunctionType_t k_type, cnrtQueue_t queue,
    mluOpDataType_t k_datatype, void *output, TensorShape output_shape,
    size_t size, uint32_t value, uint32_t value_high, uint32_t value_low) {
  cnnlDataType_t cnnl_k_datatype = convertDatatype(k_datatype);
  MLUUnion1KernelFillHostValueWithStride<<<k_dim, k_type, queue>>>(
      output, output_shape, size, value, value_high, value_low,
      cnnl_k_datatype);
}
