/*************************************************************************
 * Copyright (C) [2019-2022] by Cambricon, Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/

#include "kernels/kernel.h"

#include "kernels/poly_nms/intersect_area.h"
#include "kernels/poly_nms/poly_nms.h"


#define CALC_GENMASK_NRAM_SIZE MAX_NRAM_SIZE
#define CALC_GENMASK_NRAM_FLT_CAP CALC_GENMASK_NRAM_SIZE / sizeof(float)

namespace {

__nram__ float nram_gen_mask[CALC_GENMASK_NRAM_FLT_CAP];

template <PointDirection POINT_DIR>
__mlu_func__ static inline float IOU(
    const QuadClipBox<POINT_DIR> *__restrict__ clipbox,
    const float *__restrict__ box_j, float area_i, float area_j) {
  float intersect = IntersectArea<POINT_DIR>(box_j, clipbox);
  return intersect / (area_i + area_j - intersect);
}

__mlu_func__ static inline void MaySuppress(uint32_t *mask, int j) {
  int pos_j = j / MASK_T_BITWIDTH;
  int offset = j % MASK_T_BITWIDTH;
  constexpr uint32_t DEFAULT_MASK = 0x80000000;  // 0b 1000 0000 0000 0000
  mask[pos_j] &= ~(DEFAULT_MASK >> offset);
}

__mlu_func__ static inline bool IsCW(const float *__restrict__ dev_A) {
  Point2D *A = (Point2D *)nram_gen_mask;
  __memcpy(A, dev_A, 8 * sizeof(float), GDRAM2NRAM);
  float x0 = A[2].x - A[0].x;
  float y0 = A[2].y - A[0].y;
  float x1 = A[3].x - A[1].x;
  float y1 = A[3].y - A[1].y;
  return (x0 * y1 - y0 * x1) < 0;
}

template <PointDirection POINT_DIR>
__mlu_func__ static inline void MLUGenNMSMaskImpl(
    const float *__restrict__ input_boxes, int input_boxes_num, int real_width,
    float threshold, const float *__restrict__ boxes_area, uint32_t *mask,
    int *sort_info) {
  // support larger size.
  int mask_col_num = (input_boxes_num + MASK_T_BITWIDTH - 1) / MASK_T_BITWIDTH;

  // load boxes data into nram and remove padding
  float *box_buffer = nram_gen_mask;
  __memcpy_async(box_buffer, input_boxes, 9 * sizeof(float), GDRAM2NRAM,
                 9 * sizeof(float), real_width * sizeof(float),
                 input_boxes_num - 1);

  // load box area into nram
  float *area_buffer = box_buffer + input_boxes_num * 9;
  __memcpy_async(area_buffer, boxes_area, input_boxes_num * sizeof(float),
                 GDRAM2NRAM);

  // create mask_buffer for a single row
  constexpr uint32_t allones = 0xFFFFFFFF;
  constexpr int default_mask_v = allones;

  uint32_t *mask_buffer = (uint32_t *)area_buffer + input_boxes_num;
  uint32_t *mask_buffer_swap = mask_buffer + mask_col_num;
  __bang_write_value(mask_buffer, mask_col_num * 2, default_mask_v);

  // get the rows this core should handle
  int core_box_num = 0;
  int box_i_beg = 0;
  GetCoreWorkingSet(input_boxes_num, &core_box_num, &box_i_beg);
  int box_i_end = box_i_beg + core_box_num;
  box_i_end = box_i_end < input_boxes_num ? box_i_end : input_boxes_num;

  // __sync_io();
  __asm__ __volatile("sync;");  // guzh

  for (int i = box_i_beg; i < box_i_end; i += 1) {
    int i_pos = 0;
    float *box_i = &box_buffer[i * 9];
    QuadClipBox<POINT_DIR> clip_box;
    // clip_box.AddLines(reinterpret_cast<const Point2D *>(box_i)); //guzh

    clip_box.AddLines((const Point2D *)((void *)box_i));  // guzh

    float score_i = box_i[8];
    for (int j = 0; j < input_boxes_num; ++j) {
      if (i == j) {
        continue;
      }

      float *box_j = &box_buffer[j * 9];
      float score_j = box_j[8];
      if (score_i < score_j) {
        i_pos += 1;
      } else {
        if (score_i == score_j) {
          i_pos += (j < i);
        } else {
          float iou = IOU(&clip_box, box_j, area_buffer[i], area_buffer[j]);
          if (iou > threshold) {
            MaySuppress(mask_buffer, j);
          }
        }
      }
    }
    __memcpy(mask + i * mask_col_num, mask_buffer,
             mask_col_num * sizeof(uint32_t), NRAM2GDRAM);
    __memcpy_async(sort_info + i_pos, &i, sizeof(int), NRAM2GDRAM);
    uint32_t *tmp = mask_buffer;
    mask_buffer = mask_buffer_swap;
    mask_buffer_swap = tmp;
    __bang_write_value(mask_buffer_swap, mask_col_num,
                       default_mask_v);  // reset to all 1
  }
}

}  // namespace

__mlu_global__ void MLUGenNMSMask(const float *__restrict__ input_boxes,
                                  int input_boxes_num, int real_width,
                                  float threshold,
                                  const float *__restrict__ boxes_area,
                                  uint32_t *mask, int *sort_info) {
  if (IsCW(input_boxes)) {
    return MLUGenNMSMaskImpl<PointDirection::CW>(input_boxes, input_boxes_num,
                                                 real_width, threshold,
                                                 boxes_area, mask, sort_info);
  } else {
    return MLUGenNMSMaskImpl<PointDirection::CCW>(input_boxes, input_boxes_num,
                                                  real_width, threshold,
                                                  boxes_area, mask, sort_info);
  }
}
