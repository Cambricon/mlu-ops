/*************************************************************************
 * Copyright (C) [2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/
#include "sgetrf2.h"

#include "core/logging.h"
#include "kernels/debug.h"
#include "kernels/kernel.h"

__mlu_entry__ void MLUKernelMyCnrtMemcpy2D(
    int batch, int m, int n,
    float *dA, int ldda, int stride_a,
    float *dB, int lddb, int stride_b,
    int mode)
{
    int id, batch_id, tx, taskdim;

    if (batch > 1)
    {
        id = taskId;
        batch_id = id / 4;
        if (batch_id >= batch)
            return;
        tx = taskId % 4;
        dA += batch_id * stride_a;
        dB += batch_id * stride_b;
        taskdim = TaskUnion1;
    }
    else
    {
        id = taskId;
        batch_id = 0;
        taskdim = taskDim;
        tx = taskId;
    }

    if (mode == 0)
        __gdramset(dB, m * lddb, 0);

    int iter_n = 1;
    int iter_m = CEILDIV(m, taskdim);

    if (mode == 0)
    {
        for (int i = 0; i < iter_m; i++)
        {
            __gdramset(dB + tx * lddb + tx, 1, 1.f, lddb, 0);
            for (int j = 0; j < iter_n; j++)
            {
                if (tx < m && tx > 0)
                {

                    int dataSize = tx;

                    __memcpy(dB + j * dataSize + tx * lddb, dA + j * dataSize + tx * ldda, dataSize * sizeof(float), GDRAM2GDRAM, lddb * sizeof(float), ldda * sizeof(float), 0);
                }
            }
            tx += TaskUnion1;
        }
    }
    else
    {
        if (tx == 0)
            __memcpy(dB, dA, n * sizeof(float), GDRAM2GDRAM, lddb * sizeof(float), ldda * sizeof(float), m - 1);
    }
}

mluOpStatus_t MLUOP_WIN_API KernelMyCnrtMemcpy2D(cnrtDim3_t k_dim, cnrtFunctionType_t k_type,
                                                 cnrtQueue_t queue, mluOpDataType_t d_type,
                                                 int batch, int m, int n,
                                                 float *dA, int ldda, int stride_a,
                                                 float *dB, int lddb, int stride_b,
                                                 int mode)
{
    KERNEL_CHECK(
        MLUKernelMyCnrtMemcpy2D<<<k_dim, k_type, queue>>>(batch, m, n,
                                                          dA, ldda, stride_a,
                                                          dB, lddb, stride_b,
                                                          mode));

    return MLUOP_STATUS_SUCCESS;
}