/*************************************************************************
 * Copyright (C) [2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/
#include "sgetrf.h"

#include "core/logging.h"
#include "kernels/debug.h"
#include "kernels/kernel.h"

#define MAX_SIZE 1024
#define CEILDIV(x, y) ((x + y - 1) / y)
#define ROUNDUP(x, y) (CEILDIV(x, y) * y)
__mlu_entry__ void MLUKernelMyCnrtMemcpy2D(
    int m, int n,
    float *dA, int ldda,
    float *dB, int lddb,
    int mode)
{
    if (mode == 0)
        __gdramset(dB, m * lddb, 0);

    int tx = taskIdX;
    // int iter_n=CEILDIV(n,MAX_SIZE);
    int iter_n = 1;
    int iter_m = CEILDIV(m, TaskUnion1);

    if (mode == 0)
    {
        for (int i = 0; i < iter_m; i++)
        {
            // printf("%.f %d %d\n",*(dB+tx*lddb+tx),tx,tx);
            __gdramset(dB + tx * lddb + tx, 1, 1.f, lddb, 0);
            for (int j = 0; j < iter_n; j++)
            {
                if (tx < m && tx > 0)
                {

                    int dataSize = tx;

                    __memcpy(dB + j * dataSize + tx * lddb, dA + j * dataSize + tx * ldda, dataSize * sizeof(float), GDRAM2GDRAM, lddb * sizeof(float), ldda * sizeof(float), 0);
                }
            }
            tx += TaskUnion1;
        }
    }
    else
    {
        if (tx == 0)
            __memcpy(dB, dA, n * sizeof(float), GDRAM2GDRAM, lddb * sizeof(float), ldda * sizeof(float), m - 1);
    }
}

mluOpStatus_t MLUOP_WIN_API KernelMyCnrtMemcpy2D(cnrtDim3_t k_dim, cnrtFunctionType_t k_type,
                                                 cnrtQueue_t queue, mluOpDataType_t d_type,
                                                 int m, int n,
                                                 float *dA, int ldda,
                                                 float *dB, int lddb,
                                                 int mode)
{
    KERNEL_CHECK(
        MLUKernelMyCnrtMemcpy2D<<<k_dim, k_type, queue>>>(m, n, dA, ldda, dB, lddb, mode));

    return MLUOP_STATUS_SUCCESS;
}