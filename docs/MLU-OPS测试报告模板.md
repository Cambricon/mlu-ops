**_本测试报告模板是希望能帮助算子开发者在完成算子开发后进行有效充分的自检，开发出功能、性能都满足要求的高质量算子。_**

# 1. 功能测试

功能测试主要需要考虑以下几点：

1. 算子支持的模式是否覆盖全，例如 Convolution 算子支持的 pad, stride, ... 组合、LayerNorm 算子 axis 参数、BatchNormForward 的可选输入/可选输出等算子模式是否已覆盖所有典型的合法情况；

2. 算子支持的不同输入规模是否覆盖全，例如 Convolution 算子的 kernel = 1x1 的情况、batch 数为 1,3,4,8,16,64,128... 的情况 、channel 数为 1,3,64,2048,... 的情况，要注意主动去覆盖一些 corner case，提高测试的代码覆盖率；

3. 算子支持的数据类型是否覆盖全，例如 Convolution 支持的 INT8/INT16/INT31 以及合法的数据类型交叉 、ReduceMax 算子支持 INT32 输出类型等；

4. 算子支持的张量维度是否覆盖全，例如 BatchNormForward 支持 4 维和 5 维张量、激活类算子支持 1~8 维张量等；

5. 算子支持的张量数据摆放方式是否覆盖全，例如 BMM/MatMul 支持 transpose 参数、Convolution, BatchNormForward 后续会支持 NCHW/NHWC 的数据摆放方式等；

6. 算子稳定性是否有验证，例如不停机连续跑 5000 次；

7. 要给出防呆测试的结果，例如不合法的参数、不合法的数据摆放方式、不合法的张量形状等等需要覆盖，在测试报告中覆盖；

### 1.1 精度验收标准

见 [MLU-OPS 精度验收标准](./MLU-OPS精度验收标准.md)

给出算子分类，及其对应的精度验收标准。

### 1.2 新特性测例 CheckList（新特性添加必填）

|                测试点                | 验收标准                                                                |             测试结果（精度）              | 备注 |
| :----------------------------------: | :---------------------------------------------------------------------- | :---------------------------------------: | :--: |
|             数据类型测试             | 例如：HALF/FLOAT/INT8                                                   | 测试例数目和精度量级，可以截 gtest/pytest 结果图 | 必选 |
|             多维张量测试             | 例如：支持 1-8 维                                                       | 测试例数目和精度量级，可以截 gtest/pytest 结果图 | 必选 |
|             Layout 测试              | 例如：支持 NCHW/NHWC                                                    | 测试例数目和精度量级，可以截 gtest/pytest 结果图 | 必选 |
| 不同规模 / 整数余数端段 / 对齐不对齐 | 需要针对算子逻辑做对应的测试设计并保证测试通过                          | 测试例数目和精度量级，可以截 gtest/pytest 结果图 | 必选 |
|       零维张量测试/0 元素测试        | 如果支持则需通过                                                        |            可以截 gtest/pytest 结果图            | 必选 |
|              稳定性测试              | 1.gtest 多线程+repeat 1000 以上\* \*使用--gtest_repeat=NUM 和--thread=NUM<br>2.pytest repeat 1000 以上 使用@pytest.mark.repeat(1000) 或者 @pytest.mark.parametrize("repeat", range(1000)) | 测试例数目和精度量级，可以截 gtest/pytest 结果图 | 必选 |
|              其他测试点              |                                                                         |                                           |      |

**_关于功能测试，是希望算子开发者能够针对每一个逻辑，每一个分支，每一个判断，进行对应的测例设计，尽量覆盖到所有代码逻辑。_**

### **1.3 算子防呆测试**

提交新算子时，给出测试点，并说明测试结果。

| 测试点         | 验收标准 | 测试结果（出错信息） |
| -------------- | -------- | -------------------- |
| 不符合算子限制 | 正常报错 |                      |
| 非法参数传递   | 正常报错 |                      |

# 2. 性能测试（输出 2 个部分内容）

见 [MLU-OPS 性能验收标准](./MLU-OPS性能验收标准.md)。性能测试主要需要考虑以下几点，见：

- 要排除机器环境的影响，尽量找一个可以独占服务器的时间段来做性能测试。

- 用于性能测试的测试例，推荐使用此算子在典型网络中的规模，并构造不同维度范围的规模进行测试。

- 尽量考虑对尽可能多的规模进行性能测试，得到性能状态。

- 建议测试相同规模/参数，不同 datatype（例如 half/float）的性能，分析加速比是否合理。

- 算子 latency 建议既包括 end2end time，也包括 kernel time （hardware time），目的是能够比较清楚的看到加载时、运行时的耗时分布。

### 2.1 输出算子的 io 利用率、计算效率

```
io_efficiency = theory_io_size / (latency * IO_BANDWIDTH)
```

`theory_io_size` 表示从算法上需要访问的数据量（与实现无关），`lantency` 表示算子运行的实际时间，`IO_BANDWIDTH` 为硬件的理论带宽。

```
compute_efficiency = theory_compute_ops / (latency * peak_compute_force)
```

`theory_compute_ops` 表示该算子从算法上需要执行多少次操作（与实现无关）， `lantency` 表示算子运行的实际时间，`peak_compute_force` 为硬件平台的峰值算力，其单位是 op/s（每秒执行多少次操作）

# 3. 总结分析

总结分析主要需要考虑以下几点：

1. 需要对功能、性能测试结果有一个总结性的一句话描述；

2. 对于功能测试中发现的问题，例如精度不达标、规模受限等问题，需要显式列出；

3. 对于性能测试中 efficiency 异常、与对标硬件 latency 或 efficiency 相比差别过大（好于 / 坏于 都要包括）等情况，给出分析解释；
