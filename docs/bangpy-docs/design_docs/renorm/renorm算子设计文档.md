# BANGPy Renorm 算子开发设计方案

- #### 文档基本信息

| 算子名称     | Renorm         |
| ----------- | -------------- |
| 编制人/日期  | testouya/2022-5-18 |
| 审批人/日期  |              |

- #### 修改记录

| 修订人           | 修订日期    | 修订描述 |
| --------------- | ---------- | ------- |
| testouya  | 2022-5-18 | 首次提交 |

- #### 内容描述

本文档为 `Renorm` 算子的设计文档，包括需求分析、接口设计、方案设计、性能优化记录和方案实施部分。

## 1 需求分析

### 1.1 算子需求分析

| 算子功能简介               | 对张量进行renorm                   |
| ------------------------ | ----------------------------------------|
| 需求来源                  | 为bangpy-ops提供算子demo                  |
| 应用网络                  |                                  |
| 输入数据类型               | float                             |
| 输入 Shape                | input: [ length, N ];  |
| 输入 Layout               | input: ARRAY;           |
| 输出数据类型               | float                              |
| 输出 Shape                | [ length, N ]                               |
| 输出 Layout               | ARRAY                                    |

### 1.2 算子功能和应用场景描述

功能：对张量进行renorm操作，让指定维度的子张量的范数不超过maxnorm

```
x = torch.tensor([[1., 1., 1.],
        [2., 2., 2.],
        [3., 3., 3.]])

ret = torch.renorm(x, 1, 0, 5)

output:
tensor([[1.0000, 1.0000, 1.0000],
        [1.6667, 1.6667, 1.6667],
        [1.6667, 1.6667, 1.6667]])
```

应用场景：ResNet等

### 1.3 算子输入输出参数要求

| 参数   | 语义                  | 类型（输入/输出）| 支持类型     | 物理布局 | 规模限制      |
| ------ | --------------------- | -------------    | -----------  | ------   | --------      |
| input | 多维buffer | 输入     |  float           | ARRAY        |  无      | --------      |
| output | 多维buffer | 输出     |  float           | ARRAY        |  无      | --------      |

### 1.4 算子限制

| 限制类型       | 详细说明                    |
| ------------   | -----------------------     |
| 数据类型限制   | float            |
| 布局限制       | 仅支持ARRAY的layout         |
| 规模限制       |                             |

### 1.5 验收标准

#### 1.5.1 精度验收标准

本算子属于 `算术` 类算子.

#### 1.5.2 性能验收标准

待定。

## 2 算子接口设计

### 2.1 参考接口

- pytorch

```python
torch.renorm(input, p, dim, maxnorm)
input：输入张量
p：计算范数时，指数取值
dim：要对哪个维度的子张量进行renorm
maxnorm：子张量最大范数
```

### 2.2 接口设计

```python
Renorm(input, p, dim, maxnorm)

input：输入张量
p：计算范数时，指数取值
dim：要对哪个维度的子张量进行renorm
maxnorm：子张量最大范数

```

如果一个张量x, 维度是 [2, 3, 4]
当dim为1时，
第i, j 个子张量为
t = [
x[i, 0, j], 
x[i, 1, j], 
x[i, 2, j] 
]

## 3 实现方案设计

### 3.1 实现方案

1 根据dim划分子向量

2 将子向量平均划分到多个核上，每个核负责处理一组，例如一共有640个子向量，16个核，那么每个核处理40个子向量，不涉及一个子向量分摊到多个核上面，
例如某个子向量前半部分数据由第一个核计算，后半部分数据由第二个核计算，这种情况我们不考虑

3 每个核，计算自己需要处理的子向量。根据子向量长度，要分两种情况，子向量长度大于nram容量，和小于nram容量，如果大于，跳转4，否则，跳转6

4 逐个计算子向量p范数，将它分批拷贝进nram，需要拷贝多次

5 用子向量范数和maxnorm比较， 如果超过了，就对它进行缩小处理，跳转到 8

6 根据nram大小，计算可以容纳子向量个数，将它们拷贝进来。
例如nram容量是 400k，一个子向量长度为1k，那么一次就处理400个子向量

7 计算子向量p范数，和maxnorm比较，如果超过了，就对其进行缩小处理

8 将结果拷贝回cpu

### 3.2 拆分(任务拆分，多核拆分)

采用的tasktype固定为UNION1，数据拆分到多核内计算

### 3.3 性能优化设计
### 3.4 伪代码实现

```python

sub_tensors = get_last_dim(input)  #按照最后一个维度，将该tensor划分，拿到所有子向量

for t in sub_tensors:
    length = calc_distance(t)
    if length > maxnorm:
        resize(t)

```
### 3.5 可维护性设计


### 3.6 测试用例设



### 3.7 算子防呆检查

除host端自动生成的部分参数防呆检查外，暂不需要进行其他的防呆检查。

## 4 算子性能优化记录

### 4.1 当前存在问题的规模说明

| 提交日期  | 问题规模 | 问题描述 | 是否已修复 |
| --------- | -------- | -------- | ---------- |
|           |          |          |            |

### 4.2 已经过优化的规模说明

| 提交日期  | 修复规模 | 修复问题 |
| --------- | -------- | -------- |
|           |          |          |

## 5 方案实施

### 5.1 开发测试计划

2022.6.30 算子入库

### 5.2 风险分析

暂无。