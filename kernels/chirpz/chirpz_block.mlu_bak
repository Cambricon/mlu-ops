/*************************************************************************
 * Copyright (C) [2024] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/
#include "chirpz.h"
#include "core/logging.h"
#include "kernels/debug.h"
#include "kernels/kernel.h"
#include "kernels/utils/common.h"

#define ALIGN_NUM 64
// #include "kernels/unary_op/unary_op_3pipeline.h"
// #include "kernels/unary_op/unary_op_5pipeline.h"

__nram__ int8_t nram_buffer[MAX_NRAM_SIZE];


__mlu_global__ void MLUKernelChirpz(const int length, int n, int pad_n, int type, bool chirpz,
                                 float *output) {

  if(taskId == 0) {
    __gdramset(output, 2 * pad_n, (float)0);
  }
  
  const int32_t num_deal =
      PAD_DOWN(MAX_NRAM_SIZE / 4 / sizeof(float), ALIGN_NUM);

  // const int32_t num_deal = 10;
  float *nram_index = (float *)nram_buffer;
  float *nram_temp = nram_index + num_deal;
  float *nram_temp2 = nram_temp + num_deal;

  int num_per_core = length / taskDim;
  const int core_offset = taskId*num_per_core*2;

  float *output_gdram = output + core_offset;
  const int rem = length % taskDim;
  int total_count = num_per_core;
  if (taskId == taskDim - 1) {
      total_count += rem;
  }
  if(total_count == 0) {
    return;
  }
  int repeat = total_count / num_deal;
  int repeat_rem = total_count % num_deal;

  int real_length = 0;

  // __bang_printf("length, n, type, chirpz: %d %d %d %d\n", length, n, type,
  //               chirpz);
  // __bang_printf(
  //     "num_deal, num_per_core, core_offset, repeat_rem, repeat total_count: %d %d %d %d %d %d\n",
  //     num_deal, num_per_core, core_offset, repeat_rem, repeat, total_count);

  for (int i = 0; i < repeat+1; i++) {
    int start = taskId * num_per_core + i*num_deal;
    if(i == repeat){
      if (repeat_rem > 0) {
          real_length = total_count - repeat *num_deal;
          // __bang_printf("repeat, real_length: %d %d\n", i, real_length);
      } else {
          return;
      }
    } else {
      real_length = num_deal;
    }

    __bang_write_value(nram_index, 4*num_deal, (float)0);
    __mluop_get_indices(nram_index, start, real_length);
    // if(taskId == 3) {
    // __bang_printf("taskId, start, real_length, repeat:%d %d %d %d\n",taskId, start, real_length, i);
    // for(int k = 0; k < real_length; k++) {
    //     __bang_printf("%f ", nram_index[k]);
    // }
    // __bang_printf("\n");
    // }

    if(!chirpz){
      __bang_write_value(nram_temp, real_length, (float)n);
      __bang_sub(nram_index, nram_index, nram_temp, real_length);
    }
    // __bang_printf("__bang_square\n");
    // for (int k = 0; k < real_length; k++) {
    //     __bang_printf("%f ", nram_index[k]);
    // }
    // __bang_printf("\n");
    __bang_square(nram_index, nram_index, real_length);
    __bang_mul_scalar(nram_index, nram_index, M_PI, real_length);
    __bang_write_value(nram_temp, real_length, (float)n);
    // __bang_div(nram_temp, nram_index, nram_temp, real_length);
    __cn_vector_div_f32_rn(real_length, nram_temp, nram_index, nram_temp);

    // __bang_printf("__cn_vector_div_f32_rn\n");
    // for (int k = 0; k < real_length; k++) {
    //     __bang_printf("%f ", nram_temp[k]);
    // }
    // __bang_printf("\n");
    // __bang_recip(nram_temp, nram_temp, num_deal);
    // __bang_mul(nram_temp, nram_index, nram_temp, num_deal);

    // __bang_printf("__cn_vector_div_f32_rn\n");
    // for (int k = 0; k < real_length; k++) {
    //     __bang_printf("%f ", nram_temp[k]);
    // }
    // __bang_printf("\n");

    // __bang_div(nram_index, nram_index, nram_temp, num_deal);
    __bang_move(nram_index, nram_temp, real_length*sizeof(float));
    // __bang_mul_scalar(nram_index, nram_index, M_PI, 2*num_deal);
    // no good
    // __bang_cos(nram_index, nram_index, real_length);
    // __bang_sin(nram_temp, nram_temp, real_length);

    __cn_vector_cos_f32(real_length, nram_index, nram_index);
    __cn_vector_sin_f32(real_length, nram_temp, nram_temp);

    // __bang_cos(nram_index, nram_index, num_deal);
    // __bang_sin(nram_temp, nram_temp, num_deal);


    // __bang_printf("start: %d\n", start);
    if(chirpz){
      __bang_mul_scalar(nram_temp, nram_temp, (float)type, real_length);
    } else {
      __bang_mul_scalar(nram_temp, nram_temp, (float)-type, real_length);
    }

    __bang_transpose(nram_temp2, nram_index, 2, num_deal);
    // __bang_printf("core_offset, real_length: %d %d\n", core_offset, real_length);

    __memcpy(output_gdram + i* num_deal*2, nram_temp2, 2*real_length*sizeof(float), NRAM2GDRAM);
  }
  // for(int j = 0; j < length;j++)
  // {
  //   __bang_printf("%f ", output_gdram[j]);
  // }
  // __bang_printf("\n");
}

    // for(int j = 0; j < length;j++)
    // {
    //     __bang_printf("%f ", nram_index[j]);
    // }
    // __bang_printf("\n");
    // for(int j = 0; j < length;j++)
    // {
    //     __bang_printf("%f ", nram_temp[j]);
    // }
    // __bang_printf("\n");
    // __bang_printf("repeat deal_n length PAD_N %d %d\n", repeat, deal_n, length, PAD_N);
    // if (chirpz) {
    //   __memcpy(output_gdram + repeat * deal_n, nram_index, length*sizeof(float), NRAM2GDRAM, sizeof(float)*PAD_N, sizeof(float)*deal_n, 2);
    // } else {
    //   __memcpy(output_gdram + repeat * deal_n, nram_temp2, 2*length*sizeof(float), NRAM2GDRAM);
    // }

    // __bang_printf("output_gdram result\n");

    // if(chirpz) {
    //   for(int j = 0; j < PAD_N;j++)
    //   {
    //       __bang_printf("%f %f ", output_gdram[j], output_gdram[j+PAD_N]);
    //   }
    //   __bang_printf("\n");
    // } else {
    //   __bang_printf("PAD_N: %d \n", PAD_N);
    //   for(int j = 0; j < 2*PAD_N;j=j+2)
    //   {
    //       __bang_printf("%f %f ", output_gdram[j], output_gdram[j+1]);
    //   }
    //   __bang_printf("\n");
    // }

mluOpStatus_t MLUOP_WIN_API KernelChirpz(
    const cnrtDim3_t k_dim, const cnrtFunctionType_t k_type,
    const cnrtQueue_t queue, const int length, int n, int pad_n,
    int type,  bool chirpz, void *output) {
      KERNEL_CHECK(MLUKernelChirpz<<<k_dim, k_type, queue>>>(
          length, n, pad_n, type, chirpz, (float *)output));
    return MLUOP_STATUS_SUCCESS;
}
