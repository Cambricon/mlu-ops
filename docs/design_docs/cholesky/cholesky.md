# MLU Cholesky 分解实现方案



## 1 Cholesky分解算法介绍

Cholesky分解是科学和数值领域中最重要的算法之一。Cholesky算法是指将一个厄密特矩阵分解成一个下三角矩阵与其共轭转置之乘积，这种分解方式可以提高代数运算效率。

### 1.1 厄密特矩阵

厄密特矩阵，又称自伴随矩阵，是共轭对称的方阵。厄密特矩阵中对角线元素均为实数，且每个第i行j列的元素都与第j行i列的元素互为共轭转置。例如：
```math
\begin{bmatrix}
3 & 2+i  \\
2-i & 1 \\
\end{bmatrix}
```
对于一个矩阵$`A`$，如果其是厄密特矩阵，则可以对其进行Cholesky分解，如果其是正定矩阵（对于所有的非零实数$`x`$，都有$`x^TAx>0`$）则Cholesky分解的结果唯一，否则结果不唯一。

### 1.2 Cholesky分解

对正定厄密特矩阵$`A`$进行Cholesky分解，即求矩阵$`L`$使下式成立：
```math
A=LL^*
```
其中，$`L`$是一个下三角矩阵且对角元素均为正实数，$`L^*`$表示$`L`$的共轭转置，是一个上三角矩阵。当$`A`$是一个实数矩阵时，Cholesky分解可以改写为
```math
A=LL^T
```
下文中为表述方便，所有矩阵$`A`$均为实数矩阵。

对于一个$`n\times n`$的实矩阵$`A`$，Cholesky分解可以被写作如下过程：
```math
\begin{align*}
\begin{bmatrix}
a_{11} & a_{12} & a_{13} & a_{14} \\
a_{21} & a_{22} & a_{23} & a_{24} \\
a_{31} & a_{32} & a_{33} & a_{34} \\
a_{41} & a_{42} & a_{43} & a_{44} \\
\end{bmatrix}
&=
\begin{bmatrix}
l_{11} & 0 & 0 & 0 \\
l_{21} & l_{22} & 0 & 0 \\
l_{31} & l_{32} & l_{33} & 0 \\
l_{41} & l_{42} & l_{43} & l_{44} \\
\end{bmatrix}
\begin{bmatrix}
l_{11} & l_{21} & l_{31} & l_{41} \\
0 & l_{22} & l_{32} & l_{42} \\
0 & 0 & l_{33} & l_{43} \\
0 & 0 & 0 & l_{44} \\
\end{bmatrix} \\
&=
\begin{bmatrix}
l_{11}^2 & l_{11}l_{21} & l_{11}l_{31} & l_{11}l_{41} \\
l_{11}l_{21} & l_{21}^2 + l_{22}^2 & l_{21}l_{31} + l_{22}l_{32} & l_{21}l_{41} + l_{22}l_{42} \\
l_{11}l_{31} & l_{21}l_{31} + l_{22}l_{32} & l_{31}^2 + l_{32}^2 + l_{33}^2 & l_{31}l_{41} + l_{32}l_{42} + l_{33}l_{43} \\
l_{11}l_{41} & l_{21}l_{41} + l_{22}l_{42} & l_{31}l_{41} + l_{32}l_{42} + l_{33}l_{43} & l_{41}^2 + l_{42}^2 + l_{43}^2 + l_{44}^2 \\
\end{bmatrix}
\end{align*}
```

根据上式不难看出，每个$`a_{i,j}`$等于由$`l_{i,j}`$和$`L`$矩阵的其它元素组成的多项式，例如$`a_{32}=l_{21}l_{31}+l_{32}l_{22}`$，并且多项式中只有一个项包含了$`l_{i,j}`$（$`a_{32}`$等价的多项式中只有$`l_{22}l_{32}`$这一项），包含了$`l_{i,j}`$的项另一个因子都为对角线元素，因此为了计算$`l_{i,j}`$，可以由$`a_{i,j}`$减去不包含$`l_{i,j}`$的其它项然后除以对角线元素，这样就能算出每个$`l_{i,j}`$。

## 2 Cholesky分解实现

将输入矩阵进行分块，然后使用以下流程计算Cholesky分解：

![image](timeline.png)
图1 cholesky分解时间线

上图中，假设矩阵$`L`$的左边两列块已经计算完毕（黄色部分的非对角元和红色的对角元），这个流程展示了计算中间列块的过程（蓝色部分和橙色部分），完整的Cholesky计算只需要对分块后的所有列重复执行此流程。

SYRK(HERK)、GEMM和TRSM均为标准BLAS库中的操作，POTRF为计算对角块（完整矩阵的对角元素所在的块）内部依赖的kernel。下面将按照计算顺序依次介绍。

### 2.1 SYRK(HERK)

SYRK是BLAS的标准操作（数据类型是复数时为HERK），定义为：
```math
C=\alpha AA^T+\beta C
```
其中$`C`$为$`n\times n`$的方阵，$`A`$为$`n\times m`$的矩阵，$`\alpha`$和$`\beta`$是标量。

此处使用SYRK是为了计算橙色块的外部依赖，上式中的$`C`$代表橙色对角块（完整矩阵的对角元素所在的块），$`A`$代表橙色块左侧的所有黄色块，$`\alpha`$、$`\beta`$分别取-1和1。

![image](syrk.png)
图2 syrk示意

### 2.2 GEMM

GEMM是BLAS的标准操作，定义为：
```math
C=\alpha AB+\beta C
```
其中$`C`$，$`A`$，$`B`$分别是$`m\times n`$，$`m\times k`$，$`k\times n`$的矩阵，$`\alpha`$和$`\beta`$是标量。

这里使用GEMM计算蓝色非对角块的外部依赖，上式的$`C`$代表蓝色块，$`A`$和$`B`$分别代表橙色块左侧的黄色块和蓝色块左侧的黄色块。$`\alpha`$和$`\beta`$分别为-1和1。

![image](gemm.png)
图3 gemm示意

### 2.3 TRSM

TRSM是BLAS的标准函数，定义为：
```math
XA=\alpha B
```
已知下三角矩阵$`A`$和矩阵$`B`$，TRSM解出矩阵$`X`$，$`A`$为$`n\times n`$方阵，$`X`$和$`B`$为$`m\times n`$的矩阵。

对角块在SYRK后需要经过POTRF完成后续计算，这里假设已经计算完毕，于是可以通过TRSM完成蓝色块的剩余计算，TRSM执行后蓝色部分计算完毕。上式中$`A`$为红色块，$`X`$和$`B`$均为蓝色块，计算结果覆盖原矩阵。

![image](trsm.png)
图4 trsm示意

### 3.4 POTRF

POTRF这个函数名取自LAPACK中Cholesky分解的函数，POTRF的目的是计算橙色对角块的所有依赖，POTRF执行后对角块中的所有元素计算完毕。

对于POTRF计算的块边长的典型取值为512，这仍然是一个较大的规模，为了进一步分解，将其分成四个部分：

![image](potrf.png)
图5 potrf示意

由于输入矩阵是对角块，因此右上角部分忽略不计，剩下三个部分分别称作P1、P2、P3。

对于P1，它和POTRF的输入矩阵（完整的橙色矩阵）结构完全一致，因此直接递归调用POTRF进行计算，当P1的规模小于设定值时停止递归开始计算，后文详细介绍计算方法。

对于P2，使用TRSM即可完成对P2部分的计算，使用方式和上文相同。

![image](recur_p1.png)
图6 递归计算potrf中P1部分

对于P3，使用syrk可以完成P3外部依赖的计算，剩下的内部依赖继续调用POTRF即可完成计算。

![image](recur_p2.png)
递归计算potrf中P3部分

接下来介绍递归停止时计算POTRF的实现，此时输入矩阵的典型规模为32，将其分成若干8x8的小块，然后计算每个列块（由小块组成的列）

![image](divide.png)
图7 最后一步划分

每个列块，仍然需要先计算该列块的外部依赖（该列块左侧的所有列块），然后对列块中的每一列分别计算内部依赖，对于这两个部分可以分别用两个kernel来实现。由于这一步骤是严重的串行瓶颈，因此在划分小块时需要尽量让计算的快更小，减少串行瓶颈对性能的影响

## 3 MLU层需求分析

### 3.1 算子需求分析

|                         算子功能简介                         | 对厄密特矩阵进行Cholesky分解 |
| :----------------------------------------------------------: | :--------------------------: |
|                           需求来源                           |           pytorch            |
|                           应用网络                           |              -               |
|                         输入数据类型                         |     float/complex float      |
|                          输入Shape                           |         [batch,N,N]          |
|                          输入Layout                          |      input/output:ARRAY      |
|                         输出数据类型                         |     float/complex float      |
|                          输出Shape                           |         [batch,N,N]          |
|                          输出Layout                          |            ARRAY             |
|                             模式                             |              无              |
| 是否含有 dim/axis 等类似语义的参数且该参数支持负数/其他特殊处理 |              无              |
| 是否含有 labels/index 等类似语义的参数且该参数支持负数/界外情况/其他特殊处理 |              无              |
|                       是否需要支持原位                       |              是              |
|                    是否需要支持stride机制                    |              是              |
|                       是否需要支持广播                       |              否              |
|                    0元素检查是否直接返回                     |              无              |
|                         其他特殊需求                         |              无              |
|                 本次开发优先支持的规模/模式                  |      batch<=32，N<=3072      |

### 3.2 算子功能和应用场景描述

厄密特矩阵，又称自伴随矩阵，是共轭对称的方阵。

对正定厄密特矩阵$`A`$进行Cholesky分解，即求矩阵$`L`$使下式成立：
```math
A=LL^*
```
其中，$`L`$是一个下三角矩阵且对角元素均为正实数，$`L^*`$表示$`L`$的共轭转置，是一个上三角矩阵。当$`A`$是一个实数矩阵时，Cholesky分解可以改写为
```math
A=LL^T
```

### 3.3 算子输入输出参数要求

|    参数     |      语义      | 类型 |       支持类型       |  物理布局   |     规模限制      |
| :---------: | :------------: | :--: | :------------------: | :---------: | :---------------: |
|   handle    |                | 句柄 |                      |      /      |        无         |
| input_desc  |   矩阵描述符   | 输入 |                      |             |                   |
|   d_input   |    输入矩阵    | 输入 | float、complex float | [batch,N,N] | batch<=32,N<=3072 |
| output_desc | 输出矩阵描述符 | 输入 | float、complex float |             |                   |
|  d_output   |    输出矩阵    | 输出 |                      | [batch,N,N] |                   |
|    upper    | 上三角/下三角  | 输入 |         bool         |             |                   |



## 4 算子接口设计

接口为：

```c++
void mluOpCholesky(mluOpHandle_t handle,const mluOpTensorDescriptor_t input_desc,float* d_input, const mluOpTensorDescriptor_t output_desc, float* d_output,bool upper)
```

变量含义为上文所述。

## 5 总结

本文介绍了在MLU上实现Cholesky分解的方案和需求分析。Cholesky分解是一种分解正定厄密特矩阵为下三角矩阵及其共轭转置的算法，广泛应用于科学和数值计算。本文首先解释了厄密特矩阵和Cholesky分解的基本原理，随后通过将输入矩阵分块，并利用BLAS标准操作中的的SYRK、GEMM和TRSM函数，以及自定义POTRF函数，展示了如何逐步实现分解。然后本文详细描述了算子的需求，包括支持的数据类型、形状、布局，以及特定的计算需求，如原位操作和步长机制，并提供了算子的接口设计。