/*************************************************************************
 * Copyright (C) [2019-2022] by Cambricon, Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/

#include "mlu.h"
#include "core/mlu_op_core.h"
#include "kernels/poly_nms/pnms.h"
#include "pnms_detection.h"

#define NRAM_BUF_SIZE (MAX_NRAM_SIZE)
// #define SIZE_SRAM_BUF (MAX_SRAM_SIZE)
#define SIZE_SRAM_BUF (128 * 1024)

__nram__ char nram_buffer[NRAM_BUF_SIZE];
__mlu_shared__ char sram_buffer[SIZE_SRAM_BUF];

__mlu_func__ void boxesTranspose(const void *input_boxes,
                                 const int input_num_boxes,
                                 const int input_stride, void *output,
                                 void *buffer, const int buffer_size,
                                 const mluOpDataType_t data_type_input) {
  __bang_printf("launch boxesTranspose start \n");

  if (coreId == 0) {
    if (input_num_boxes * input_stride * 4 > buffer_size) {
      __bang_printf("transpose failed. input num is over large.\n");
      return;
    }

// Trans boxes: Nx9 -> 9xN
#if __BANG_ARCH__ >= 300
    __bang_printf("transpose:__BANG_ARCH__ >=300\n");

    float *boxes;
    float *trans_boxes;
    boxes = (float *)buffer;
    trans_boxes = boxes + input_num_boxes * input_stride;
    // Transpose no need to align
    __memcpy((float *)boxes, (float *)input_boxes,
             input_num_boxes * input_stride * 4, GDRAM2NRAM);
    __bang_transpose((float *)trans_boxes, (float *)boxes, input_num_boxes,
                     input_stride);
    __memcpy((float *)output, (float *)trans_boxes,
             input_num_boxes * input_stride * 4, NRAM2GDRAM);
#else
    __bang_printf("transpose:__BANG_ARCH__ < 300\n");
    const int ALIGN_SIZE = 128;
    const int align_num = ALIGN_SIZE / 4;
    // align input_stride->align_stride, align  input_num_boxes->align_box_num
    int align_box_num = CEIL_ALIGN(input_num_boxes, align_num);
    int align_stride = CEIL_ALIGN(input_stride, align_num);
    int transpose_num = align_box_num * align_stride;
    if (transpose_num * 2 * 4 > buffer_size) {
      __bang_printf("transpose failed. input num is over large.\n");
      return;
    }
    float *boxes;
    float *trans_boxes;
    boxes = (float *)buffer;
    trans_boxes = (float *)boxes + transpose_num;
    __memcpy((float *)boxes, (float *)input_boxes, input_stride * sizeof(float),
             GDRAM2NRAM, align_stride * sizeof(float),
             input_stride * sizeof(float), input_num_boxes);

    __bang_transpose((float *)trans_boxes, (float *)boxes, align_box_num,
                     align_stride);

    __memcpy((float *)output, (float *)trans_boxes,
             input_num_boxes * sizeof(float), NRAM2GDRAM,
             input_num_boxes * sizeof(float), align_box_num * sizeof(float),
             input_stride);
#endif  // BANG_ARCH if
  }
  __sync_cluster();
  __bang_printf("launch boxesTranspose end\n");
}

__mlu_global__ void MLUUnion1OrBlockPNMS(const void *input_boxes,
                                         int input_num_boxes, int input_stride,
                                         const float iou_thresh,
                                         void *result_num, void *output,
                                         const mluOpDataType_t data_type_input,
                                         void *workspace) {
  void *trans_boxes = (char *)workspace;
  __bang_printf("[cnnlPolyNms] launch transpose kernel start.\n");
  boxesTranspose(input_boxes, input_num_boxes, input_stride, trans_boxes,
                 nram_buffer, NRAM_BUF_SIZE, data_type_input);
  __bang_printf("[cnnlPolyNms] launch transpose kernel end.\n");

  uint32_t input_data_num = input_stride * input_num_boxes;  // N*P
  input_stride = input_num_boxes;                            // N
  // PERF_TIME_BEGIN();

  uint32_t *out_data = (uint32_t *)output;
  switch (data_type_input) {
    case MLUOP_DTYPE_FLOAT: {
      pnms_detection<float, uint32_t>(
          (uint32_t *)result_num, out_data, (float *)trans_boxes,
          (float *)nram_buffer, NRAM_BUF_SIZE, (float *)sram_buffer, taskDim,
          input_data_num, input_stride, iou_thresh);
    }; break;
    default: { __bang_printf("Not Implemented.\n"); }
  }
  // PERF_TIME_END();
}
