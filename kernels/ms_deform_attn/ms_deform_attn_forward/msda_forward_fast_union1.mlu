/*************************************************************************
 * Copyright (C) [2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/
#include "ms_deform_attn_utils.h"

#pragma bang walign(64)

#define NRAM_REMAIN_SIZE (48 * 1024)
#define NRAM_AVALIABLE_SIZE (__MLU_NRAM_SIZE__ * 1024 - NRAM_REMAIN_SIZE)


__nram__ char nram_buffer[NRAM_AVALIABLE_SIZE];

__mlu_func__ void broadcastSpatialHW(
  float* spatial_offset_bd_nram,  // (num_levels, num_points)
  float* spatial_h_bd_nram,       // (num_levels, num_points)
  float* spatial_w_bd_nram,       // (num_levels, num_points)
  int32_t* spatial_shapes_nram,   // (num_levels, 2)
  int32_t* spatial_offset_nram,   // (num_levels)
  const int32_t num_levels, const int32_t num_points) {
  __bang_int322float((float*)spatial_shapes_nram, spatial_shapes_nram,
                    num_levels * 2, 0);
  for(int i = 0; i < num_levels; i++) {
    __memcpy(spatial_h_bd_nram + i * num_points,
            spatial_shapes_nram + i * 2, sizeof(float),
            NRAM2NRAM, sizeof(float), 0, num_points - 1);
  }
  for(int i = 0; i < num_levels; i++) {
    __memcpy(spatial_w_bd_nram + i * num_points,
            spatial_shapes_nram + 1 + i * 2, sizeof(float),
            NRAM2NRAM, sizeof(float), 0, num_points - 1);
  }
  __bang_int322float((float*)spatial_offset_nram, spatial_offset_nram,
                    num_levels, 0);
  for(int i = 0; i < num_levels; i++) {
    __memcpy(spatial_offset_bd_nram + i * num_points,
            spatial_offset_nram + i, sizeof(float),
            NRAM2NRAM, sizeof(float), 0, num_points - 1);
  }
}

template <typename T>
__mlu_func__ void getConditionCoordWeight(
    int32_t* data_offset_nram, T* weight_polation_nram,
    T* cond_point_polation_nram, T* cond_point_valid_nram, T* loc_nram,
    T* weight_attn_nram, int8_t* mask_x_nram, int8_t* mask_y_nram,
    T* spatial_offset_bd_nram, T* spatial_w_bd_nram, T* spatial_h_bd_nram,
    T* buf_nram, const int32_t deal_n, const int32_t num_levels, const int32_t num_points,
    const int32_t num_heads, const int32_t channels) {
  int32_t total_points = deal_n * num_levels * num_points;
  int32_t block_points = num_levels * num_points;
  T* buf_x_nram = buf_nram;
  T* buf_y_nram = buf_nram + total_points;
  T* buf_cond_nram = buf_nram + 2 * total_points;
  T* buf_x_floor = buf_nram + 2 * total_points;
  T* buf_x_ceil = buf_nram + 3 * total_points;
  T* buf_y_floor = buf_nram + 4 * total_points;
  T* buf_y_ceil = buf_nram + 5 * total_points;
  //================================================================================================
  int32_t total_coord_pad = PAD_UP(total_points * 2, BIT_COLLECT_PAD);
  __bang_collect_bitindex(buf_x_nram, loc_nram, mask_x_nram, total_coord_pad);
  __bang_collect_bitindex(buf_y_nram, loc_nram, mask_y_nram, total_coord_pad);
  // x = loc_x * spatial_w - 0.5; y = loc_y * spatial_h - 0.5;
  __bang_fusion(FUSION_FMS, buf_x_nram, buf_x_nram, spatial_w_bd_nram, (T)0.5,
                total_points, block_points);
  __bang_fusion(FUSION_FMS, buf_y_nram, buf_y_nram, spatial_h_bd_nram, (T)0.5,
                total_points, block_points);
  //================================================================================================
  // get point condition. use buf0, buf1, buf2
  // (x > -1 && y > -1 && y < spatial_h && x < spatial_w)
  __bang_gt_scalar(cond_point_valid_nram, buf_x_nram, (T)-1.0, total_points);
  __bang_gt_scalar(buf_cond_nram, buf_y_nram, (T)-1.0, total_points);
  __bang_and(cond_point_valid_nram, cond_point_valid_nram, buf_cond_nram,
             total_points);
  __bang_cycle_lt(buf_cond_nram, buf_x_nram, spatial_w_bd_nram, total_points,
                  block_points);
  __bang_and(cond_point_valid_nram, cond_point_valid_nram, buf_cond_nram,
             total_points);
  __bang_cycle_lt(buf_cond_nram, buf_y_nram, spatial_h_bd_nram, total_points,
                  block_points);
  __bang_and(cond_point_valid_nram, cond_point_valid_nram, buf_cond_nram,
             total_points);
  //================================================================================================
  __bang_floor(buf_x_floor, buf_x_nram, total_points);
  __bang_add_scalar(buf_x_ceil, buf_x_floor, 1.0, total_points);
  __bang_floor(buf_y_floor, buf_y_nram, total_points);
  __bang_add_scalar(buf_y_ceil, buf_y_floor, 1.0, total_points);
  T* cond_point_polation_nram_tl = cond_point_polation_nram;
  T* cond_point_polation_nram_bl = cond_point_polation_nram + total_points;
  T* cond_point_polation_nram_tr = cond_point_polation_nram + 2 * total_points;
  T* cond_point_polation_nram_br = cond_point_polation_nram + 3 * total_points;
  T* cond_point_polation_nram_cond1 = weight_polation_nram;
  T* cond_point_polation_nram_cond2 = weight_polation_nram + total_points;
  T* cond_point_polation_nram_cond3 = weight_polation_nram + 2 * total_points;
  T* cond_point_polation_nram_cond4 = weight_polation_nram + 3 * total_points;
  __bang_ge_scalar(cond_point_polation_nram_cond1, buf_x_floor, (T)0,
                   total_points);
  __bang_cycle_lt(cond_point_polation_nram_cond2, buf_x_ceil, spatial_w_bd_nram,
                  total_points, block_points);
  __bang_ge_scalar(cond_point_polation_nram_cond3, buf_y_floor, (T)0,
                   total_points);
  __bang_cycle_lt(cond_point_polation_nram_cond4, buf_y_ceil, spatial_h_bd_nram,
                  total_points, block_points);
  __bang_and(cond_point_polation_nram_tl, cond_point_polation_nram_cond1,
             cond_point_polation_nram_cond4, total_points);
  __bang_and(cond_point_polation_nram_bl, cond_point_polation_nram_cond1,
             cond_point_polation_nram_cond3, total_points);
  __bang_and(cond_point_polation_nram_tr, cond_point_polation_nram_cond2,
             cond_point_polation_nram_cond4, total_points);
  __bang_and(cond_point_polation_nram_br, cond_point_polation_nram_cond2,
             cond_point_polation_nram_cond3, total_points);
  //================================================================================================
  // get polation weight.
  T* buf_dx = (T*)data_offset_nram;
  T* buf_dy = buf_dx + total_points;
  T* buf_dx_1 = buf_dy + total_points;
  T* buf_dy_1 = buf_dx_1 + total_points;
  // -dx = x_floor-x
  // -dy = y_floor-y
  // w1 = (1-dx)*dy     = (dx-1)*(-dy)
  // w2 = (1-dx)*(1-dy) = (dx-1)*(dy-1)
  // w3 = dx*dy         = (-dx)*(-dy)
  // w4 = dx*(1-dy)     = (-dx)*(dy-1)
  T* weight_polation_nram_1 = weight_polation_nram;
  T* weight_polation_nram_2 = weight_polation_nram + 1 * total_points;
  T* weight_polation_nram_3 = weight_polation_nram + 2 * total_points;
  T* weight_polation_nram_4 = weight_polation_nram + 3 * total_points;
  // T* weight_polation_nram_buf = buf_nram + 4 * total_points;
  __bang_sub(buf_dx, buf_x_floor, buf_x_nram, total_points);
  __bang_sub(buf_dy, buf_y_floor, buf_y_nram, total_points);
  __bang_fusion(FUSION_FSS, buf_dx_1, buf_x_nram, buf_x_floor, (T)1.0,
                total_points, total_points);
  __bang_fusion(FUSION_FSS, buf_dy_1, buf_y_nram, buf_y_floor, (T)1.0,
                total_points, total_points);
  __bang_mul(weight_polation_nram_1, buf_dx_1, buf_dy, total_points);
  __bang_mul(weight_polation_nram_2, buf_dx_1, buf_dy_1, total_points);
  __bang_mul(weight_polation_nram_3, buf_dx, buf_dy, total_points);
  __bang_mul(weight_polation_nram_4, buf_dx, buf_dy_1, total_points);
  //================================================================================================
  // correct the x,y in [0, w-1] and [0, h-1]
  T* spatial_w1_bd_nram = buf_nram;
  T* spatial_h1_bd_nram = buf_nram + block_points;
  __bang_sub_scalar(spatial_w1_bd_nram, spatial_w_bd_nram, (T)1, block_points);
  __bang_sub_scalar(spatial_h1_bd_nram, spatial_h_bd_nram, (T)1, block_points);
  __bang_maxeq_scalar(buf_x_floor, buf_x_floor, (T)0, total_points);
  __bang_maxeq_scalar(buf_x_ceil, buf_x_ceil, (T)0, total_points);
  __bang_cycle_minequal(buf_x_floor, buf_x_floor, spatial_w1_bd_nram,
                        total_points, block_points);
  __bang_cycle_minequal(buf_x_ceil, buf_x_ceil, spatial_w1_bd_nram,
                        total_points, block_points);
  __bang_maxeq_scalar(buf_y_floor, buf_y_floor, (T)0, total_points);
  __bang_maxeq_scalar(buf_y_ceil, buf_y_ceil, (T)0, total_points);
  __bang_cycle_minequal(buf_y_floor, buf_y_floor, spatial_h1_bd_nram,
                        total_points, block_points);
  __bang_cycle_minequal(buf_y_ceil, buf_y_ceil, spatial_h1_bd_nram,
                        total_points, block_points);
  //================================================================================================
  // offset = y*w + x
  T* buf_hw_offset = buf_nram;
  T* data_offset_nram_tl = (T*)data_offset_nram;
  T* data_offset_nram_bl = data_offset_nram_tl + total_points;
  T* data_offset_nram_tr = data_offset_nram_bl + total_points;
  T* data_offset_nram_br = data_offset_nram_tr + total_points;
  // y_ceil*w + offset + x_floor
  __bang_fusion(FUSION_FMA, buf_hw_offset, buf_y_ceil, spatial_w_bd_nram,
                spatial_offset_bd_nram, total_points, block_points);
  __bang_add(data_offset_nram_tl, buf_hw_offset, buf_x_floor, total_points);
  // y_ceil*w + offset + x_ceil
  __bang_add(data_offset_nram_tr, buf_hw_offset, buf_x_ceil, total_points);
  // y_floor*w + offset + x_foor
  __bang_fusion(FUSION_FMA, buf_hw_offset, buf_y_floor, spatial_w_bd_nram,
                spatial_offset_bd_nram, total_points, block_points);
  __bang_add(data_offset_nram_bl, buf_hw_offset, buf_x_floor, total_points);
  // y_floor*w + offset + x_ceil
  __bang_add(data_offset_nram_br, buf_hw_offset, buf_x_ceil, total_points);
  __bang_cycle_and(cond_point_polation_nram, cond_point_polation_nram,
                   cond_point_valid_nram, 4 * total_points, total_points);
  __bang_cycle_mul(weight_polation_nram, weight_polation_nram,
                   weight_attn_nram, 4 * total_points, total_points);
  __bang_mul(weight_polation_nram, weight_polation_nram, cond_point_polation_nram, total_points * 4);
  __bang_sub((float*)data_offset_nram_bl,
             (float*)data_offset_nram_bl,
             (float*)data_offset_nram_tl, total_points);
  __bang_sub((float*)data_offset_nram_tr,
             (float*)data_offset_nram_tr,
             (float*)data_offset_nram_tl, total_points);
}

/*
  shape of each tensor:
  output_nram:          (channels)
  input_nram:           (4, valid_num, channels)
  input_trans:          (channels, 4, valid_num)
  input_pooled:         (channels, valid_num)
  cond_selected_base:   (4, deal_n, num_levels, num_points)
  weight_selected_base: (4, deal_n, num_levels, num_points)
  weight_attn_nram:     (valid_num)
  weight_compute:       (4, valid_num)
  cond_compute:         (4, valid_num)
  input_wram:           (channels, 4 * valid_num)

  valid_num <= num_levels * num_points
  sample_stride_3 = deal_n * num_levels * num_points
*/
template <typename T>
__mlu_func__ void reduceLevelByConv(
    T* output_nram, T* input_nram, T* input_trans, T* input_pooled,
    int32_t* cond_selected_base, T* weight_selected_base, T* weight_attn_nram,
    T* weight_compute, int32_t* cond_compute, const int32_t valid_num, const int32_t channels,
    const int32_t sample_stride_3) {
    int32_t ci = 4 * valid_num;
    int32_t co = channels;
    __memcpy(weight_compute, weight_selected_base, valid_num * sizeof(T),
                   NRAM2NRAM, valid_num * sizeof(T),
                   sample_stride_3 * sizeof(T), 3);
    __bang_transpose(input_trans, input_nram, ci, co);
    __sync_move();
    __bang_cycle_mul(input_trans, input_trans, weight_compute, co * ci, ci);
    __bang_sumpool(input_pooled, input_trans, valid_num, channels, 4, 1, 4, 1,
                  1);
    __bang_sumpool(output_nram, input_pooled, 1, channels, valid_num, 1,
                  valid_num, 1, 1);
}

__mlu_func__ void loadNram2Gpr(int32_t& v1, int32_t& v2, int32_t& v3,
                               int32_t* p1, int32_t* p2, int32_t* p3, int32_t num_heads, int32_t channels_size) {
  int32_t stride = num_heads * channels_size;
  v1 = ((int32_t)__load_nram((float *)p1)) * stride;
  v2 = ((int32_t)__load_nram((float *)p2)) * stride;
  v3 = ((int32_t)__load_nram((float *)p3)) * stride;
}

/*
  Load 4 neighbors use one 3D-memcpy, just use offset of N1, stride_3_1 and
  stride_2_1.
        |<- stride_3_1 ->|
        N1               N3
        ^
        |
     stride_2_1
        |
        v
        N2               N4

  Trickly fold the loop as 2.
*/
template <typename T>
__mlu_func__ void loadDataValueXram2NramAsync(
    T* buf_value_nram_1, int32_t* offset_1, int32_t* stride_2_1,
    int32_t* stride_3_1, T* value_src, const int32_t num_levels_points,
    const int32_t channel_size, const int32_t value_stride_3_size, const int32_t num_heads) {
  int32_t offset_1_a, stride_2_1_a, stride_3_1_a;
  int32_t offset_1_b, stride_2_1_b, stride_3_1_b;
  loadNram2Gpr(offset_1_a, stride_2_1_a, stride_3_1_a, offset_1, stride_2_1,
               stride_3_1, num_heads, channel_size);
  loadNram2Gpr(offset_1_b, stride_2_1_b, stride_3_1_b, offset_1 + 1,
               stride_2_1 + 1, stride_3_1 + 1, num_heads, channel_size);
  int32_t value_offset = 0;
  int32_t next = 0;
  int32_t loop_num = num_levels_points / 2;
  int32_t remain = num_levels_points % 2;
  int32_t data_value_stride = num_levels_points * channel_size;
  for (int32_t j = 0; j < loop_num * 2; j += 2) {
    value_offset = j * channel_size;
    next = j + 2;
    for(int i = 0; i < 2; i++)
    {
      __memcpy_async((int8_t*)buf_value_nram_1 + value_offset + data_value_stride * i,
                     (int8_t*)value_src + offset_1_a + i * stride_2_1_a,
                      channel_size, GDRAM2NRAM, 2 * data_value_stride, stride_3_1_a, 1);
    }

    loadNram2Gpr(offset_1_a, stride_2_1_a, stride_3_1_a, offset_1 + next,
                 stride_2_1 + next, stride_3_1 + next, num_heads, channel_size);
    for(int i = 0; i < 2; i++)
    {
      __memcpy_async((int8_t*)buf_value_nram_1 + value_offset + channel_size + data_value_stride * i,
                     (int8_t*)value_src + offset_1_b + i * stride_2_1_b,
                      channel_size, GDRAM2NRAM, 2 * data_value_stride, stride_3_1_b, 1);
    }

    loadNram2Gpr(offset_1_b, stride_2_1_b, stride_3_1_b, offset_1 + next + 1,
                 stride_2_1 + next + 1, stride_3_1 + next + 1, num_heads, channel_size);
  }

  if (remain > 0) {
    value_offset = loop_num * 2 * channel_size;
    for(int i = 0; i < 2; i++)
    {
      __memcpy_async((int8_t*)buf_value_nram_1 + value_offset + data_value_stride * i,
                     (int8_t*)value_src + offset_1_a + i * stride_2_1_a,
                      channel_size, GDRAM2NRAM, 2 * data_value_stride, stride_3_1_a, 1);
    }
  }
}

template <typename T>
__mlu_func__ void loadNeighborPolationAttn(
    T* value_output_nram, T* value_gdram,
    int32_t* data_offset_nram, T* weight_polation_nram,
    T* cond_point_polation_nram, T* cond_point_valid_nram, T* weight_attn_nram,
    T* buf_nram, T* compute_buf_nram, T* nram_ones, const int32_t deal_n,
    const int32_t num_levels, const int32_t num_points, const int32_t num_keys,
    const int32_t channels, const int32_t num_heads) {
  int32_t channel_size = channels * sizeof(T);
  int32_t sample_stride_3 = deal_n * num_levels * num_points;
  int32_t value_stride_3 = num_levels * num_points * channels;
  int32_t value_stride_3_size = value_stride_3 * sizeof(T);
  T* buf_value_nram = buf_nram;  // (4, num_levels, num_points, channels)
  T* buf_value_nram_trans =
      buf_nram + 4 * value_stride_3;  // (4, num_levels, num_points, channels)
  T* buf_value_nram_pool =
      buf_nram + 8 * value_stride_3;  // (1, num_levels, num_points, channels)
  T* weight_compute_nram = compute_buf_nram;      // (4, num_levels, num_points)
  int32_t* cond_compute_nram =
      (int32_t*)(weight_compute_nram + 4 * num_levels * num_points);
  __sync_compute();

  int32_t* offset = data_offset_nram;
  int32_t* stride_2_1 = offset + sample_stride_3;
  int32_t* stride_3_1 = stride_2_1 + sample_stride_3;
  T* output_nram = value_output_nram;
  int32_t step_offset = 0;
  for (int32_t i = 0; i < deal_n; i++) {
    int32_t valid_num = num_levels * num_points;
    loadDataValueXram2NramAsync<T>(
        buf_value_nram, offset, stride_2_1, stride_3_1, value_gdram, valid_num,
        channel_size, value_stride_3_size, num_heads);
    __sync_io();
    reduceLevelByConv(
        output_nram, buf_value_nram, buf_value_nram_trans, buf_value_nram_pool,
        (int32_t*)cond_point_polation_nram + step_offset,
        weight_polation_nram + step_offset, weight_attn_nram + step_offset,
        weight_compute_nram, cond_compute_nram, valid_num,
        channels, sample_stride_3);
    step_offset += valid_num;
    offset = data_offset_nram + step_offset;
    stride_2_1 = offset + sample_stride_3;
    stride_3_1 = stride_2_1 + sample_stride_3;
    output_nram += channels;
  }
}

template <typename T>
__mlu_func__ void prepareLoop(
    T* ones_nram, int32_t* spatial_offset_nram, int32_t* spatial_hw_nram,
    int8_t* mask_x_nram, int8_t* mask_y_nram, T* spatial_offset_bd_nram,
    T* spatial_h_bd_nram, T* spatial_w_bd_nram,
    const char* data_level_start_index_gdram,
    const char* data_spatial_shapes_gdram, const int32_t num_keys,
    const int32_t num_levels, const int32_t num_points,
    const int32_t max_deal_n, const int32_t mask_size, const int32_t channels) {
  int32_t pad_num_points_levels =
      PAD_UP(num_levels * num_points, WRAM_ALIGN_SIZE / sizeof(T));
  __bang_write_value(ones_nram, pad_num_points_levels, (T)0);
  __bang_write_value(ones_nram, num_levels * num_points, (T)1);
  __bang_write_value(mask_x_nram, mask_size, (char)0x55);
  __bang_write_value(mask_y_nram, mask_size, (char)0xAA);
  __memcpy_async(spatial_offset_nram, data_level_start_index_gdram,
                 num_levels * sizeof(int32_t), GDRAM2NRAM);
  __memcpy_async(spatial_hw_nram, data_spatial_shapes_gdram,
                 num_levels * 2 * sizeof(int32_t), GDRAM2NRAM);
  __sync_io_move_compute();
  broadcastSpatialHW(spatial_offset_bd_nram, spatial_h_bd_nram,
                     spatial_w_bd_nram, spatial_hw_nram, spatial_offset_nram,
                     num_levels, num_points);
}

/*
  The shape of each tensor:
  ones_nram:                 (num_levels, num_points)
  buf_compute_nram:          (8, num_levels, num_points)
  spatial_offset_nram:       (num_levels)
  spatial_hw_nram:           (num_levels, 2)
  spatial_offset_bd_nram:    (num_levels, num_points)
  spatial_w_bd_nram:         (num_levels, num_points)
  spatial_h_bd_nram:         (num_levels, num_points)
  mask_x_nram:               (deal_n, num_levels, num_points, 2) / 8
  mask_y_nram:               (deal_n, num_levels, num_points, 2) / 8
  value_output_nram:         (deal_n, channels)
  data_offset_nram:          (4, deal_n, num_levels, num_points)
  weight_polation_nram:      (4, deal_n, num_levels, num_points)
  cond_point_polation_nram:  (4, deal_n, num_levels, num_points)
  cond_point_valid_nram:     (deal_n, num_levels, num_points)
  loc_nram:                  (deal_n, num_levels, num_points, 2)
  weight_attn_nram:          (deal_n, num_levels, num_points)
  buf_nram:                  (6, deal_n, num_levels, num_points)

  Note: buf_nram is reused in polation computing.
*/
template <typename T>
__mlu_func__ void memPolicyCommon(
    T*& buf_compute_nram, T*& ones_nram, T*& value_output_nram,
    int32_t*& data_offset_nram, T*& weight_polation_nram,
    T*& cond_point_polation_nram, T*& cond_point_valid_nram, T*& loc_nram,
    T*& weight_attn_nram, T*& buf_nram, T*& buf_nram_end, int8_t*& mask_x_nram,
    int8_t*& mask_y_nram, T*& spatial_offset_bd_nram, T*& spatial_w_bd_nram,
    T*& spatial_h_bd_nram, int32_t*& spatial_offset_nram,
    int32_t*& spatial_hw_nram, int32_t& max_deal_n,
    int32_t& mask_size, const int32_t batch_size, const int32_t num_keys,
    const int32_t num_heads, const int32_t channels, const int32_t num_levels,
    const int32_t num_queries, const int32_t num_points) {
  int32_t num_points_levels = num_levels * num_points;
  int32_t pad_num_points_levels =
      PAD_UP(num_points_levels, NFU_ALIGN_SIZE / sizeof(T));
  int32_t pad_num_points_levels_8 =
      PAD_UP(8 * num_points_levels, NFU_ALIGN_SIZE / sizeof(T));
  int32_t spatial_info_size =
      PAD_UP(3 * num_levels * sizeof(int32_t), NFU_ALIGN_SIZE);
  int32_t fix_space_size =
      spatial_info_size + 2 * BIT_COLLECT_PAD * sizeof(T) +
      (4 * pad_num_points_levels + pad_num_points_levels_8) * sizeof(T);
  int32_t left_space_size = NRAM_AVALIABLE_SIZE - fix_space_size;
  int32_t common_buffer_size_each = 6 * num_points_levels * sizeof(T);
  int32_t inter_result_size_each =
      17 * num_points_levels * sizeof(T) + channels * sizeof(T);

  max_deal_n =
      left_space_size / (common_buffer_size_each + inter_result_size_each);
  int32_t compute_buffer_size =
      (9 * num_points_levels * channels + max_deal_n) * sizeof(T);
  int32_t common_buffer_size = max_deal_n * common_buffer_size_each;
  // make sure buf_nram is large enough for compute
  if (compute_buffer_size > common_buffer_size) {
    int32_t tmp_deal_n =
        (left_space_size - compute_buffer_size) / inter_result_size_each;
    max_deal_n = __mluop_min(max_deal_n, tmp_deal_n);
  }

  int32_t total_points = max_deal_n * num_points_levels;
  int32_t total_coord_pad = PAD_UP(total_points * 2, BIT_COLLECT_PAD);
  mask_size = total_coord_pad / BIT_COLLECT_PAD;
  ones_nram = (T*)nram_buffer;
  buf_compute_nram = ones_nram + pad_num_points_levels;
  spatial_offset_nram = (int32_t*)(buf_compute_nram + pad_num_points_levels_8);
  spatial_hw_nram = spatial_offset_nram + num_levels;
  spatial_offset_bd_nram = (T*)(spatial_hw_nram + num_levels * 2);
  spatial_w_bd_nram = spatial_offset_bd_nram + num_points_levels;
  spatial_h_bd_nram = spatial_w_bd_nram + num_points_levels;
  mask_x_nram = (int8_t*)(spatial_h_bd_nram + num_points_levels);
  mask_y_nram = mask_x_nram + mask_size;
  value_output_nram = (T*)(mask_y_nram + mask_size);
  data_offset_nram = (int32_t*)(value_output_nram + max_deal_n * channels);
  weight_polation_nram = (T*)(data_offset_nram + 4 * total_points);
  cond_point_polation_nram = weight_polation_nram + 4 * total_points;
  cond_point_valid_nram = cond_point_polation_nram + 4 * total_points;
  loc_nram = cond_point_valid_nram + total_points;
  weight_attn_nram = loc_nram + total_coord_pad;
  buf_nram = weight_attn_nram + total_points;
  buf_nram_end = buf_nram + 6 * max_deal_n * num_points_levels;
}

template <typename T>
__mlu_func__ void MLUKernelMsDeformAttnForwardFastImpl(
    const char* data_value_gdram, const char* data_spatial_shapes_gdram,
    const char* data_level_start_index_gdram,
    const char* data_sampling_loc_gdram, const char* data_attn_weight_gdram,
    const int32_t batch_size, const int32_t num_keys, const int32_t num_heads,
    const int32_t channels, const int32_t num_levels, const int32_t num_queries,
    const int32_t num_points, char* data_col_gdram) {
  int32_t input_stride_4 = num_queries * num_heads * num_levels * num_points;
  int32_t input_stride_3 = num_heads * num_levels * num_points;
  int32_t input_stride_2 = num_levels * num_points;
  int32_t output_stride_3 = num_queries * num_heads * channels;
  int32_t output_stride_2 = num_heads * channels;
  int32_t data_value_stride_3 = num_keys * num_heads * channels;

  T* value_output_nram = nullptr;         // (deal_n, channels)
  int32_t* data_offset_nram = nullptr;    // (4, deal_n, num_levels, num_points)
  T* weight_polation_nram = nullptr;      // (4, deal_n, num_levels, num_points)
  T* cond_point_polation_nram = nullptr;  // (4, deal_n, num_levels, num_points)
  T* cond_point_valid_nram = nullptr;     // (deal_n, num_levels, num_points)
  T* loc_nram = nullptr;                  // (deal_n, num_levels, num_points, 2)
  T* weight_attn_nram = nullptr;          // (deal_n, num_levels, num_points)
  T* buf_nram = nullptr;                  // (6, deal_n, num_levels, num_points)
  T* buf_nram_end = nullptr;
  int8_t* mask_x_nram = nullptr;  // (deal_n, num_levels, num_points, 2) / 8
  int8_t* mask_y_nram = nullptr;  // (deal_n, num_levels, num_points, 2) / 8
  T* spatial_offset_bd_nram = nullptr;     // (num_levels, num_points)
  T* spatial_w_bd_nram = nullptr;          // (num_levels, num_points)
  T* spatial_h_bd_nram = nullptr;          // (num_levels, num_points)
  int32_t* spatial_offset_nram = nullptr;  // (num_levels)
  int32_t* spatial_hw_nram = nullptr;      // (num_levels, 2)
  T* buf_compute_nram = nullptr;           // (8, num_levels, num_points)
  T* ones_nram = nullptr;                  // (1, num_levels, num_points)
  int32_t max_deal_n = 0;
  int32_t mask_size = 0;
  memPolicyCommon(buf_compute_nram, ones_nram, value_output_nram,
                  data_offset_nram, weight_polation_nram,
                  cond_point_polation_nram, cond_point_valid_nram, loc_nram,
                  weight_attn_nram, buf_nram, buf_nram_end, mask_x_nram,
                  mask_y_nram, spatial_offset_bd_nram, spatial_w_bd_nram,
                  spatial_h_bd_nram, spatial_offset_nram, spatial_hw_nram,
                  max_deal_n, mask_size, batch_size, num_keys,
                  num_heads, channels, num_levels, num_queries, num_points);
  if (max_deal_n <= 0) {
    return;
  }

  // split batch*head into taskDimY
  int32_t batch_head = batch_size * num_heads;
  int32_t cluster_avg_batch_head = (batch_head + taskDimY - 1) / taskDimY;
  int32_t cluster_begin_batch_head = taskIdY * cluster_avg_batch_head;
  int32_t cluster_act_batch_head = __mluop_min(
      cluster_avg_batch_head, batch_head - cluster_begin_batch_head);
  int32_t cluster_end_batch_head =
      cluster_begin_batch_head + cluster_act_batch_head;
  // split query into coreDim
  int32_t core_avg_query = (num_queries + coreDim - 1) / coreDim;
  int32_t core_begin_query = coreId * core_avg_query;
  int32_t core_act_query =
      __mluop_min(num_queries - core_begin_query, core_avg_query);
  int32_t core_loop_num = (core_act_query + max_deal_n - 1) / max_deal_n;
  int32_t core_step_query =
      core_loop_num > 0 ? (core_act_query + core_loop_num - 1) / core_loop_num
                        : 0;
  int32_t core_remain_query =
      core_act_query - (core_loop_num - 1) * core_step_query;
  int32_t first_deal_query =
      (int)(core_loop_num > 0) *
      (core_loop_num > 1 ? core_step_query : core_remain_query);

  prepareLoop(ones_nram, spatial_offset_nram, spatial_hw_nram, mask_x_nram,
              mask_y_nram, spatial_offset_bd_nram, spatial_h_bd_nram,
              spatial_w_bd_nram, data_level_start_index_gdram,
              data_spatial_shapes_gdram, num_keys, num_levels, num_points,
              max_deal_n, mask_size, channels);

  for (int32_t bh_idx = cluster_begin_batch_head;
       bh_idx < cluster_end_batch_head; bh_idx++) {
    int32_t b = bh_idx / num_heads;
    int32_t head_idx = bh_idx % num_heads;

    size_t output_base_offset =
        (size_t)b * output_stride_3 + head_idx * channels;
    int32_t attn_weight_base_offset =
        b * input_stride_4 + head_idx * input_stride_2;

    __sync_cluster();

    if (__is_ipu()) {
      // compute weight, offset and condition
      int32_t attn_weight_offset =
          attn_weight_base_offset + core_begin_query * input_stride_3;
      int32_t loc_offset = attn_weight_offset * 2;
      if (first_deal_query > 0) {
        __memcpy(loc_nram, (T*)data_sampling_loc_gdram + loc_offset,
                 input_stride_2 * 2 * sizeof(T), GDRAM2NRAM,
                 input_stride_2 * 2 * sizeof(T), input_stride_3 * 2 * sizeof(T),
                 first_deal_query - 1);
        __memcpy(
            weight_attn_nram, (T*)data_attn_weight_gdram + attn_weight_offset,
            input_stride_2 * sizeof(T), GDRAM2NRAM, input_stride_2 * sizeof(T),
            input_stride_3 * sizeof(T), first_deal_query - 1);
        getConditionCoordWeight<T>(
            data_offset_nram, weight_polation_nram, cond_point_polation_nram,
            cond_point_valid_nram, loc_nram, weight_attn_nram, mask_x_nram,
            mask_y_nram, spatial_offset_bd_nram, spatial_w_bd_nram,
            spatial_h_bd_nram, buf_nram,
            first_deal_query, num_levels, num_points, num_heads, channels);
      }
    }

    for (int32_t i = 0; __is_ipu() && i < core_loop_num; i++) {
      int32_t deal_n =
          i < core_loop_num - 1 ? core_step_query : core_remain_query;
      int32_t load_n =
          i < core_loop_num - 2 ? core_step_query : core_remain_query;
      // load value and polation
      loadNeighborPolationAttn<T>(
          value_output_nram,
          (T*)data_value_gdram + b * data_value_stride_3 + head_idx * channels,
          data_offset_nram, weight_polation_nram, cond_point_polation_nram,
          cond_point_valid_nram, weight_attn_nram, buf_nram, buf_compute_nram,
          ones_nram, deal_n, num_levels, num_points, num_keys, channels,
          num_heads);
      __sync_io_move_compute();
      // load next weight and loc
      if (i < core_loop_num - 1) {
        int32_t core_query_offset = (i + 1) * core_step_query;
        int32_t attn_weight_offset =
            attn_weight_base_offset +
            (core_begin_query + core_query_offset) * input_stride_3;
        int32_t loc_offset = attn_weight_offset * 2;
        __memcpy_async(loc_nram, (T*)data_sampling_loc_gdram + loc_offset,
                       input_stride_2 * 2 * sizeof(T), GDRAM2NRAM,
                       input_stride_2 * 2 * sizeof(T),
                       input_stride_3 * 2 * sizeof(T), load_n - 1);
        __memcpy_async(
            weight_attn_nram, (T*)data_attn_weight_gdram + attn_weight_offset,
            input_stride_2 * sizeof(T), GDRAM2NRAM, input_stride_2 * sizeof(T),
            input_stride_3 * sizeof(T), load_n - 1);
        __sync_io_move_compute();
      }
      // store result
      size_t output_offset =
          ((size_t)core_begin_query + i * core_step_query) * output_stride_2;
      __memcpy_async((T*)data_col_gdram + output_base_offset + output_offset,
                     value_output_nram, channels * sizeof(T), NRAM2GDRAM,
                     output_stride_2 * sizeof(T), channels * sizeof(T),
                     deal_n - 1);

      // compute cond/weight/offset
      if (i < core_loop_num - 1) {
        getConditionCoordWeight<T>(
            data_offset_nram, weight_polation_nram, cond_point_polation_nram,
            cond_point_valid_nram, loc_nram, weight_attn_nram, mask_x_nram,
            mask_y_nram, spatial_offset_bd_nram, spatial_w_bd_nram,
            spatial_h_bd_nram, buf_nram,
            load_n, num_levels, num_points, num_heads, channels);
      }
      __sync_io_move_compute();
    }
    __sync_cluster();
  }
}

template <typename T>
__mlu_global__ void MLUKernelMsDeformAttnForwardFast(
    const char* data_value_gdram, const char* data_spatial_shapes_gdram,
    const char* data_level_start_index_gdram,
    const char* data_sampling_loc_gdram, const char* data_attn_weight_gdram,
    const int32_t batch_size, const int32_t num_keys, const int32_t num_heads,
    const int32_t channels, const int32_t num_levels, const int32_t num_queries,
    const int32_t num_points, char* data_col_gdram) {
    MLUKernelMsDeformAttnForwardFastImpl<float>(
        data_value_gdram, data_spatial_shapes_gdram,
        data_level_start_index_gdram, data_sampling_loc_gdram,
        data_attn_weight_gdram, batch_size, num_keys, num_heads, channels,
        num_levels, num_queries, num_points, data_col_gdram);
}

template __mlu_global__ void MLUKernelMsDeformAttnForwardFast<float>(
    const char* data_value_gdram, const char* data_spatial_shapes_gdram,
    const char* data_level_start_index_gdram,
    const char* data_sampling_loc_gdram, const char* data_attn_weight_gdram,
    const int32_t batch_size, const int32_t num_keys, const int32_t num_heads,
    const int32_t channels, const int32_t num_levels, const int32_t num_queries,
    const int32_t num_points, char* data_col_gdram);
