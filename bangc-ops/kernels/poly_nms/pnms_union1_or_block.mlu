/*************************************************************************
 * Copyright (C) [2019-2022] by Cambricon, Inc.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/

#include "core/mlu_op_core.h"
#include "kernels/kernel.h"
#include "kernels/poly_nms/pnms.h"
#include "pnms_detection.h"

#define NRAM_BUF_SIZE (MAX_NRAM_SIZE)
#define SIZE_SRAM_BUF (NRAM_BUF_SIZE)

__nram__ char nram_buffer[NRAM_BUF_SIZE];
__mlu_shared__ char sram_buffer[SIZE_SRAM_BUF];

__mlu_func__ void boxesTranspose(const void *input_boxes,
                                 const int input_boxes_num,
                                 const int input_stride, void *output,
                                 void *buffer, const int buffer_size) {
  if (coreId == 0) {
// Trans boxes: Nx9 -> 9xN
#if __BANG_ARCH__ >= 300
    float *boxes;
    float *trans_boxes;
    boxes = (float *)buffer;
    trans_boxes = boxes + input_boxes_num * input_stride;
    // Transpose no need to align
    __memcpy((float *)boxes, (float *)input_boxes,
             input_boxes_num * input_stride * sizeof(float), GDRAM2NRAM);
    __bang_transpose((float *)trans_boxes, (float *)boxes, input_boxes_num,
                     input_stride);
    __memcpy((float *)output, (float *)trans_boxes,
             input_boxes_num * input_stride * sizeof(float), NRAM2GDRAM);
#else
    const int align_num = NFU_ALIGN_SIZE / sizeof(float);
    // align input_stride->align_stride, align  input_boxes_num->align_box_num
    int align_box_num = CEIL_ALIGN(input_boxes_num, align_num);
    int align_stride = CEIL_ALIGN(input_stride, align_num);
    int transpose_num = align_box_num * align_stride;

    float *boxes;
    float *trans_boxes;
    boxes = (float *)buffer;
    trans_boxes = (float *)boxes + transpose_num;
    __memcpy((float *)boxes, (float *)input_boxes, input_stride * sizeof(float),
             GDRAM2NRAM, align_stride * sizeof(float),
             input_stride * sizeof(float), input_boxes_num);

    __bang_transpose((float *)trans_boxes, (float *)boxes, align_box_num,
                     align_stride);

    __memcpy((float *)output, (float *)trans_boxes,
             input_boxes_num * sizeof(float), NRAM2GDRAM,
             input_boxes_num * sizeof(float), align_box_num * sizeof(float),
             input_stride);
#endif  // BANG_ARCH if
  }
  __sync_cluster();
}

__mlu_global__ void MLUUnion1OrBlockPNMS(const void *input_boxes,
                                         int input_boxes_num, int input_stride,
                                         const float iou_thresh,
                                         void *result_num, void *output,
                                         const mluOpDataType_t data_type_input,
                                         void *workspace) {
  void *trans_boxes = (char *)workspace;
  boxesTranspose(input_boxes, input_boxes_num, input_stride, trans_boxes,
                 nram_buffer, NRAM_BUF_SIZE);

  int32_t input_data_num = input_stride * input_boxes_num;  // N*P
  input_stride = input_boxes_num;                           // N

  int32_t *out_data = (int32_t *)output;
  switch (data_type_input) {
    case MLUOP_DTYPE_FLOAT: {
      pnms_detection<float, int32_t>(
          (int32_t *)result_num, out_data, (float *)trans_boxes,
          (float *)nram_buffer, NRAM_BUF_SIZE, (float *)sram_buffer, taskDim,
          input_data_num, input_stride, iou_thresh);
    }; break;
    default: break;
  }
}
